var documenterSearchIndex = {"docs":
[{"location":"man/formulation.html#Formulation","page":"Formulation","title":"Formulation","text":"","category":"section"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"ProxAL is designed to solve AC Optimal Power Flow (ACOPF) formulations over multiple time periods. ","category":"page"},{"location":"man/formulation.html#Time-coupling","page":"Formulation","title":"Time coupling","text":"","category":"section"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"Each time period t in T involves the solution of an ACOPF with active p_dt and reactive q_dt load forecasts, which may differ from one time period to the next. In each time period t in T, we must determine the 'base-case' active power generation level of generator g in G, denoted by p^0_gt. The active power generations in consecutive time periods are constrained by the generator's ramping capacity, which can be modeled as follows:","category":"page"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"-r_g leq p^0_gt-1 - p^0_gt leq r_g qquad forall g in G  forall t in T setminus 1","category":"page"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"Here, r_g denotes the ramping capacity of generator g (per unit of time in which T is defined).","category":"page"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"For numerical convergence reasons, ProxAL can implement the ramping constraint in one of several different forms:","category":"page"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"Inequality: This form is exactly the same as above:","category":"page"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"-r_g leq p^0_gt-1 - p^0_gt leq r_g qquad forall g in G  forall t in T setminus 1","category":"page"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"Equality: In this form, ProxAL introduces additional continuous variables s_gt along with the following constraints:","category":"page"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"leftbeginaligned\n    0 leq s_gt leq 2r_g  \n    p^0_gt-1 - p^0_gt + s_gt = r_g\nendalignedright qquad forall g in G  forall t in T setminus 1","category":"page"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"Penalty: In this form, ProxAL introduces additional continuous variables s_gt and z_gt along with the following constraints. Note that a penalty term w_t z^2 is also added to the objective function, where the parameter w_t can be set using the weight_quadratic_penalty_time field of ProxAL.ModelParams in Model parameters.","category":"page"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"leftbeginaligned\n    0 leq s_gt leq 2r_g  \n    p^0_gt-1 - p^0_gt + s_gt + z_gt = r_g\nendalignedright qquad forall g in G  forall t in T setminus 1","category":"page"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"Which of the above the forms to use can be set using the time_link_constr_type field of ProxAL.ModelParams in Model parameters.","category":"page"},{"location":"man/formulation.html#Contingency-constraints","page":"Formulation","title":"Contingency constraints","text":"","category":"section"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"Each single-period ACOPF problem may itself be constrained further by a set of transmission line contingencies, denoted by K. The active and reactive power generations, and bus voltages must satisfy the following constraints in each time period and each contingency:","category":"page"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"the power flow equations, \nbounds on active and reactive generation and voltage magnitudes, and \nline power flow limits.","category":"page"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"It is possible that the problem parameters are such that (some of) the above constraints can become infeasible. To model this, ProxAL also allows constraint infeasibility (except variable bounds) by penalizing them in the objective function.","category":"page"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"The contingencies in each time period are linked together via their active power generations in one of several forms. The choice of the form can be set using the ctgs_link_constr_type field of ProxAL.ModelParams in Model parameters.","category":"page"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"Preventive mode: active power generation in contingency k must be equal to the base case value. This constraint can be implemented in one of two forms:  \nPreventive equality: This can be modeled as an equality:\np_gt^k = p_gt^0 qquad forall g in G  forall k in K  forall t in T\nPreventive penalty: In this form, ProxAL introduces additional continuous variables z_gkt along with the following constraints. Note that a penalty term w_k z_k ^2 is also added to the objective function, where the parameter w_k can be set using the weight_quadratic_penalty_ctgs field of ProxAL.ModelParams in Model parameters.\np_gt^k = p_gt^0 + z_gkt qquad forall g in G  forall k in K  forall t in T\nCorrective mode: active power generation is allowed to deviate from base case by up to 10% of its ramping capacity. This constraint can be implemented in one of two forms:   \nCorrective inequality: This can be modeled as an equality:\n01 r_g leq p_gt^k - p_gt^0 leq 01  r_g qquad forall g in G  forall k in K  forall t in T\nCorrective equality: In this form, ProxAL introduces additional continuous variables s_gkt along with the following constraints:\nleftbeginaligned\n  0 leq s_gkt leq 02 r_g  \n  p_gt^0 - p_gt^k + s_gkt = 01  r_g \n  endalignedright qquad forall g in G  forall k in K  forall t in T\nCorrective penalty: In this form, ProxAL introduces additional continuous variables s_gkt and z_gkt along with the following constraints. A penalty term w_k z_k  ^2 is also added to the objective function, where the parameter w_k can be set using the weight_quadratic_penalty_ctgs field of ProxAL.ModelParams in Model parameters.  \nleftbeginaligned\n    0 leq s_gkt leq 02 r_g  \n    p_gt^0 - p_gt^k + s_gkt + z_gkt = 01  r_g\nendalignedright qquad forall g in G  forall k in K  forall t in T\nFrequency control mode: In this case, ProxAL defines new continuous variables omega_kt which is the (deviation from nominal) system frequency in contingency k of time period t, and alpha_g is the droop control parameter of generator g. There is only one form of representing this constraint. The objective functions includes an additional term w_omega  omega ^2, where the parameter w_omega can be set using the weight_freq_ctrl field of ProxAL.ModelParams in Model parameters.","category":"page"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"p_gt^k = p_gt^0 + alpha_g omega_kt qquad forall g in G  forall k in K  forall t in T","category":"page"},{"location":"man/algorithm.html#Algorithm","page":"Algorithm","title":"Algorithm","text":"","category":"section"},{"location":"man/algorithm.html","page":"Algorithm","title":"Algorithm","text":"The Formulation is decomposed into smaller optimization blocks. Specifically, ProxAL.jl supports decomposition into:","category":"page"},{"location":"man/algorithm.html","page":"Algorithm","title":"Algorithm","text":"single-period multiple-contingency ACOPF problems, and \nsingle-period single-contingency ACOPF problems.","category":"page"},{"location":"man/algorithm.html","page":"Algorithm","title":"Algorithm","text":"This decomposition is achieved by formulating an Augmented Lagrangian with respect to the coupling constraints: in decomposition mode 1, these are the ramping constraints; and in mode 2, these are the ramping as well as contingency-linking constraints.","category":"page"},{"location":"man/algorithm.html","page":"Algorithm","title":"Algorithm","text":"The decomposed formulation is solved using an iterative ADMM-like Jacobi scheme with a particular choice of proximal weights, by updating first the primal variables (e.g., power generations and voltages) and then the dual variables of the coupling constraints. The Jacobi nature of the update implies that the single-block nonlinear programming (NLP) problems can be solved in parallel. ProxAL.jl allows the parallel solution of these NLP block subproblems using the MPI.jl package.","category":"page"},{"location":"lib/algparams.html","page":"Algorithm parameters","title":"Algorithm parameters","text":"CurrentModule = ProxAL","category":"page"},{"location":"lib/algparams.html#Algorithm-parameters","page":"Algorithm parameters","title":"Algorithm parameters","text":"","category":"section"},{"location":"lib/algparams.html#Description","page":"Algorithm parameters","title":"Description","text":"","category":"section"},{"location":"lib/algparams.html","page":"Algorithm parameters","title":"Algorithm parameters","text":"AlgParams","category":"page"},{"location":"lib/algparams.html#ProxAL.AlgParams","page":"Algorithm parameters","title":"ProxAL.AlgParams","text":"AlgParams\n\nSpecifies ProxAL's algorithmic parameters.\n\nParameter Description Default value\ndecompCtgs::Bool if true: decompose across contingencies (along with time) false\njacobi::Bool if true: do Jacobi updates, else do Gauss-Siedel updates true\nparallel::Bool run NLP subproblems in parallel (needs MPI) true\niterlim::Int maximum number of ProxAL iterations 100\nnlpiterlim::Int maximum number of NLP subproblem iterations 100\ntol::Float64 tolerance used for ProxAL termination 1.0e-4\nzero::Float64 tolerance below which is regarded as zero 1.0e-8\nρ_t::Any AL parameters for ramp constraints (can be different for different constraints) 1.0\nρ_c::Any AL parameters for ctgs constraints (can be different for different constraints) 1.0\nmaxρ_t::Float64 Maximum value of ρ_t 1.0\nmaxρ_c::Float64 Maximum value of ρ_c 1.0\nupdateρ_t::Bool if true: dynamically update ρ_t false\nupdateρ_c::Bool if true: dynamically update ρ_c false\nρ_t_tol::Any Tolerance for dynamic update of ρ_t 1.0e-3\nρ_c_tol::Any Tolerance for dynamic update of ρ_c 1.0e-3\nτ::Float64 Proximal weight parameter 3.0\nθ::Float64 Relaxation parameter for update of dual variables 1.0\nupdateτ::Bool if true: dynamically update τ false\nverbose::Int level of output: 0 (none), 1 (stdout), 2 (+plots), 3 (+outfiles) 0\nmode::Symbol computation mode ∈ [:nondecomposed, :coldstart, :lyapunov_bound] :nondecomposed\noptimizer::Any NLP solver nothing\n\n\n\n\n\n","category":"type"},{"location":"lib/algparams.html#API-Reference","page":"Algorithm parameters","title":"API Reference","text":"","category":"section"},{"location":"lib/algparams.html","page":"Algorithm parameters","title":"Algorithm parameters","text":"Function to initialize the AlgParams object:","category":"page"},{"location":"lib/algparams.html","page":"Algorithm parameters","title":"Algorithm parameters","text":"set_rho!","category":"page"},{"location":"lib/algparams.html#ProxAL.set_rho!","page":"Algorithm parameters","title":"ProxAL.set_rho!","text":"set_rho!(algparams::AlgParams;\n         ngen::Int,\n         maxρ_t::Float64,\n         maxρ_c::Float64,\n         modelinfo::ModelParams)\n\nInitialize algparams for an ACOPF instance with ngen generators, maximum augmented lagrangian parameter value of maxρ_t (for ramping constraints), maxρ_c (for contingency constraints), and with model parameters specified in modelinfo.\n\n\n\n\n\n","category":"function"},{"location":"man/usage.html#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"man/usage.html","page":"Usage","title":"Usage","text":"ProxAL.jl can be used called from existing Julia code or REPL, or also from the terminal.","category":"page"},{"location":"man/usage.html","page":"Usage","title":"Usage","text":"note: Note\nTo do: Update documentation to show how to use MPI.","category":"page"},{"location":"man/usage.html#Julia-code-or-REPL","page":"Usage","title":"Julia code or REPL","text":"","category":"section"},{"location":"man/usage.html","page":"Usage","title":"Usage","text":"Install ProxAL.jl via the Julia package manager (type ]):","category":"page"},{"location":"man/usage.html","page":"Usage","title":"Usage","text":"pkg> add git@github.com:exanauts/ProxAL.jl.git\npkg> test ProxAL","category":"page"},{"location":"man/usage.html","page":"Usage","title":"Usage","text":"Next, set up and solve the problem as follows. Note that all case files are stored in the data/ subdirectory. For a full list of model and algorithmic options, see Model parameters and Algorithm parameters.","category":"page"},{"location":"man/usage.html","page":"Usage","title":"Usage","text":"using ProxAL\nusing JuMP, Ipopt\n\n# Model/formulation settings\nmodelinfo = ModelParams()\nmodelinfo.case_name = \"case9\"\nmodelinfo.num_time_periods = 2\nmodelinfo.num_ctgs = 1\nmodelinfo.weight_quadratic_penalty_time = 0.1\nmodelinfo.weight_freq_ctrl = 0.1\nmodelinfo.time_link_constr_type = :penalty\nmodelinfo.ctgs_link_constr_type = :frequency_ctrl\n\n# Load case\ncase_file = \"data/\" * modelinfo.case_name\nload_file = \"data/mp_demand/\" * modelinfo.case_name * \"_oneweek_168\"\nrawdata = RawData(case_file, load_file)\nopfdata = opf_loaddata(rawdata;\n                       time_horizon_start = 1,\n                       time_horizon_end = modelinfo.num_time_periods,\n                       load_scale = modelinfo.load_scale,\n                       ramp_scale = modelinfo.ramp_scale)\n\n# Algorithm settings\nalgparams = AlgParams()\nalgparams.parallel = false\nalgparams.decompCtgs = false\nalgparams.verbose = 0\nalgparams.optimizer = JuMP.optimizer_with_attributes(Ipopt.Optimizer, \"print_level\" => 0)\nmaxρ = 0.1\nset_rho!(algparams;\n         ngen = length(opfdata.generators),\n         modelinfo = modelinfo,\n         maxρ_t = maxρ,\n         maxρ_c = maxρ)\nalgparams.mode = :coldstart\n\nif algparams.mode ∈ [:nondecomposed, :lyapunov_bound]\n    solve_fullmodel(opfdata, rawdata, modelinfo, algparams)\nelseif algparams.mode == :coldstart\n    run_proxALM(opfdata, rawdata, modelinfo, algparams)\nend","category":"page"},{"location":"man/usage.html#Terminal","page":"Usage","title":"Terminal","text":"","category":"section"},{"location":"man/usage.html","page":"Usage","title":"Usage","text":"The examples/ directory provides an example of how ProxAL.jl can be set up to be used from the terminal. Enter julia examples/main.jl --help to get a help message:","category":"page"},{"location":"man/usage.html","page":"Usage","title":"Usage","text":"usage: main.jl [--T T] [--Ctgs CTGS] [--time_unit UNIT]\n               [--ramp_value RVAL] [--decompCtgs] [--ramp_constr RCON]\n               [--Ctgs_constr CCON] [--load_scale LSCALE]\n               [--quad_penalty QPEN] [--auglag_rho RHO]\n               [--compute_mode MODE] [-h] case\n\npositional arguments:\n  case                 Case name [case9, case30, case118,\n                       case1354pegase, case2383wp, case9241pegase]\n\noptional arguments:\n  --T T                No. of time periods (type: Int64, default: 10)\n  --Ctgs CTGS          No. of line ctgs (type: Int64, default: 0)\n  --time_unit UNIT     Select: [hour, minute] (default: \"minute\")\n  --ramp_value RVAL    Ramp value: % Pg_max/time_unit (type: Float64,\n                       default: 0.5)\n  --decompCtgs         Decompose contingencies\n  --ramp_constr RCON   Select: [penalty, equality, inequality]\n                       (default: \"penalty\")\n  --Ctgs_constr CCON   Select: [frequency_ctrl, preventive_penalty,\n                       preventive_equality, corrective_penalty,\n                       corrective_equality, corrective_inequality]\n                       (default: \"preventive_equality\")\n  --load_scale LSCALE  Load multiplier (type: Float64, default: 1.0)\n  --quad_penalty QPEN  Qaudratic penalty parameter (type: Float64,\n                       default: 1000.0)\n  --auglag_rho RHO     Aug Lag parameter (type: Float64, default: 1.0)\n  --compute_mode MODE  Choose from: [nondecomposed, coldstart,\n                       lyapunov_bound] (default: \"coldstart\")\n  -h, --help           show this help message and exit","category":"page"},{"location":"man/usage.html","page":"Usage","title":"Usage","text":"A typical call might look as follows:","category":"page"},{"location":"man/usage.html","page":"Usage","title":"Usage","text":"julia examples/main.jl case9 --T=2 --Ctgs=1 --time_unit=hour --ramp_value=0.5 --load_scale=1.0 --ramp_constr=penalty --Ctgs_constr=frequency_ctrl --auglag_rho=0.1 --quad_penalty=0.1 --compute_mode=coldstart","category":"page"},{"location":"index.html#ProxAL","page":"Home","title":"ProxAL","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"ProxAL.jl is a Julia package to solve multiperiod contingency-constrained AC Optimal Power Flow (ACOPF) problems. Its main feature is a distributed parallel implementation, which allows running on high-performance computing architectures. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This document describes the algorithm, API and main functions of ProxAL.jl.","category":"page"},{"location":"index.html#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"index.html#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"man/formulation.md\",\n    \"man/algorithm.md\",\n    \"man/usage.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Library","page":"Home","title":"Library","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"lib/modelparams.md\",\n    \"lib/algparams.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This research was supported by the Exascale Computing Project, a joint project of the U.S. Department of Energy’s Office of Science and National Nuclear Security Administration.","category":"page"},{"location":"lib/modelparams.html","page":"Model parameters","title":"Model parameters","text":"CurrentModule = ProxAL","category":"page"},{"location":"lib/modelparams.html#Model-parameters","page":"Model parameters","title":"Model parameters","text":"","category":"section"},{"location":"lib/modelparams.html#Description","page":"Model parameters","title":"Description","text":"","category":"section"},{"location":"lib/modelparams.html","page":"Model parameters","title":"Model parameters","text":"ModelParams","category":"page"},{"location":"lib/modelparams.html#ProxAL.ModelParams","page":"Model parameters","title":"ProxAL.ModelParams","text":"ModelParams\n\nSpecifies the ACOPF model structure.\n\nParameter Description Default value\nnum_time_periods::Int number of time periods 1\nnum_ctgs::Int number of line contingencies 0\nload_scale::Float64 load multiplication factor 1.0\nramp_scale::Float64 multiply this with p_g^max to get generator ramping r_g 1.0\nobj_scale::Float64 objective multiplication factor 1.0e-3\nallow_obj_gencost::Bool model generator cost true\nallow_constr_infeas::Bool allow constraint infeasibility false\nweight_constr_infeas::Float64 quadratic penalty weight for constraint infeasibilities 1.0\nweight_freq_ctrl::Float64 quadratic penalty weight for frequency violations 1.0\nweight_ctgs::Float64 linear weight of contingency objective function 1.0\nweight_quadratic_penalty_time::Float64 see Formulation 1.0\nweight_quadratic_penalty_ctgs::Float64 see Formulation 1.0\ncase_name::String name of case file \"\"\nsavefile::String name of save file \"\"\ntime_link_constr_type::Symbol ∈ [:penalty, :equality, :inequality] see Formulation :penalty\nctgs_link_constr_type::Symbol ∈ [:frequency_ctrl, :preventive_penalty, :preventive_equality, :corrective_penalty, :corrective_equality, :corrective_penalty], see Formulation :preventive_equality\n\n\n\n\n\n","category":"type"}]
}
