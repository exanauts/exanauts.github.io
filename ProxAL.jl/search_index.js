var documenterSearchIndex = {"docs":
[{"location":"lib/developer.html","page":"Developer reference","title":"Developer reference","text":"CurrentModule = ProxAL","category":"page"},{"location":"lib/developer.html#Developer-reference","page":"Developer reference","title":"Developer reference","text":"","category":"section"},{"location":"lib/developer.html#NLP-Blocks","page":"Developer reference","title":"NLP Blocks","text":"","category":"section"},{"location":"lib/developer.html","page":"Developer reference","title":"Developer reference","text":"The Formulation is decomposed into smaller nonlinear programming (NLP) blocks. Blocks are coupled together using a OPFBlocks structure.","category":"page"},{"location":"lib/developer.html","page":"Developer reference","title":"Developer reference","text":"OPFBlocks","category":"page"},{"location":"lib/developer.html#ProxAL.OPFBlocks","page":"Developer reference","title":"ProxAL.OPFBlocks","text":"OPFBlocks(\n    opfdata::OPFData,\n    rawdata::RawData;\n    modelinfo::ModelParams = ModelParams(),\n    backend=JuMPBlockModel,\n    algparams::AlgParams = AlgParams()\n)\n\nCreate a structure OPFBlocks to decompose the original OPF problem specified in opfdata timestep by timestep, by dualizing the ramping constraint. One block corresponds to one optimization subproblem (and hence, to a particular timestep), and the attribute blkCount enumerates the total number of subproblems. The subproblems are specified using AbstractBlockModel objects, allowing to define them either with JuMP (if backend=JuMPBlockModel is chosen) or with ExaPF (backend=ExaBlockModel).\n\nDecomposition by contingencies\n\nBy default, OPFBlocks decomposes the problem only timestep by timestep (single-period multiple-contingency scheme), leading to a total of T subproblems. However, if the option algparams.decompCtgs is set to true, the original problem is also decomposed contingency by contingency (single-period single-contingency scheme). In this case the total number of subproblems is T * K (with K the total number of contingencies).\n\nDeporting the resolution on the GPU\n\nWhen the backend is set to ExaBlockModel (and a CUDA GPU is available), the user could chose to deport the resolution of each subproblem directly on the GPU simply by setting algparams.device=CUDADevice. However, note that we could not instantiate more subproblems on the GPU than the number of GPU available.\n\n\n\n\n\n","category":"type"},{"location":"lib/developer.html","page":"Developer reference","title":"Developer reference","text":"Internally, each block is represented as follows.","category":"page"},{"location":"lib/developer.html","page":"Developer reference","title":"Developer reference","text":"AbstractBlockModel\nJuMPBlockModel\nExaBlockModel\ninit!\noptimize!\nset_objective!\nget_solution\nadd_variables!\n","category":"page"},{"location":"lib/developer.html#ProxAL.AbstractBlockModel","page":"Developer reference","title":"ProxAL.AbstractBlockModel","text":"AbstractBlockModel\n\nAbstract supertype for the definition of block subproblems.\n\n\n\n\n\n","category":"type"},{"location":"lib/developer.html#ProxAL.JuMPBlockModel","page":"Developer reference","title":"ProxAL.JuMPBlockModel","text":"JuMPBlockModel(\n    blk::Int,\n    opfdata::OPFData, raw_data::RawData,\n    modelinfo::ModelParams, t::Int, k::Int, T::Int,\n)\n\nUse the modeler JuMP to define the optimal power flow inside the block model. This function is called inside the constructor of the structure OPFBlocks, used for decomposition purpose.\n\nArguments\n\nblk::Int: ID of the block represented by this model\nopfdata::OPFData: data used to build the optimal power flow problem.\nraw_data::RawData: same data, in raw format\nmodelinfo::ModelParams: parameters related to specification of the optimization model\nt::Int: current time-step. Value should be between 1 and T.\nk::Int: current contingency\nT::Int: final horizon\n\n\n\n\n\n","category":"type"},{"location":"lib/developer.html#ProxAL.ExaBlockModel","page":"Developer reference","title":"ProxAL.ExaBlockModel","text":"ExaBlockModel(\n    blk::Int,\n    opfdata::OPFData, raw_data::RawData,\n    modelinfo::ModelParams, t::Int, k::Int, T::Int;\n    device::TargetDevice=CPU,\n    nr_tol::Float64=1e-10,\n)\n\nUse the package ExaPF to define the optimal power flow inside the block model. This function is called inside the constructor of the structure OPFBlocks, used for decomposition purpose.\n\nArguments\n\nblk::Int: ID of the block represented by this model\nopfdata::OPFData: data used to build the optimal power flow problem.\nraw_data::RawData: same data, in raw format\nmodelinfo::ModelParams: parameters related to specification of the optimization model\nt::Int: current time-step. Value should be between 1 and T.\nk::Int: current contingency\nT::Int: final horizon\n\n\n\n\n\n","category":"type"},{"location":"lib/developer.html#ProxAL.init!","page":"Developer reference","title":"ProxAL.init!","text":"init!(block::AbstractBlockModel, algparams::AlgParams)\n\nInit the optimization model by populating the model with variables and constraints.\n\n\n\n\n\n","category":"function"},{"location":"lib/developer.html#ProxAL.optimize!","page":"Developer reference","title":"ProxAL.optimize!","text":"optimize!(block::AbstractBlockModel, x0::AbstractArray, algparams::AlgParams)\n\nSolve the optimization problem, starting from an initial variable x0. The optimization solver is specified in field algparams.optimizer.\n\n\n\n\n\n","category":"function"},{"location":"lib/developer.html#ProxAL.set_objective!","page":"Developer reference","title":"ProxAL.set_objective!","text":"set_objective!(\n    block::AbstractBlockModel,\n    algparams::AlgParams,\n    primal::PrimalSolution,\n    dual::DualSolution\n)\n\nUpdate the objective inside block's optimization subproblem. The new objective updates the coefficients of the penalty terms, to reflect the new primal and dual solutions passed in the arguments.\n\n\n\n\n\n","category":"function"},{"location":"lib/developer.html#ProxAL.get_solution","page":"Developer reference","title":"ProxAL.get_solution","text":"get_solution(block::AbstractBlockModel, output)\n\nReturn the solution of the optimization as a named tuple solution, with fields\n\nstatus::MOI.TerminationStatus: final status returned by the solver\nminimum::Float64: optimal objective found\nvm::AbstractArray: optimal values of voltage magnitudes\nva::AbstractArray: optimal values of voltage angles\npg::AbstractArray: optimal values of active power generations\nqg::AbstractArray: optimal values of reactive power generations\nωt::AbstractArray: optimal values of frequency\nst::AbstractArray: optimal values of slack variables\n\n\n\n\n\n","category":"function"},{"location":"lib/developer.html#ProxAL.add_variables!","page":"Developer reference","title":"ProxAL.add_variables!","text":"add_variables!(block::AbstractBlockModel, algparams::AlgParams)\n\nAdd all optimization variables into the decomposed optimization model block.\n\n\n\n\n\n","category":"function"},{"location":"man/formulation.html#Formulation","page":"Formulation","title":"Formulation","text":"","category":"section"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"ProxAL is designed to solve AC Optimal Power Flow (ACOPF) formulations over multiple time periods. ","category":"page"},{"location":"man/formulation.html#Time-coupling","page":"Formulation","title":"Time coupling","text":"","category":"section"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"Each time period t in T involves the solution of an ACOPF with active p_dt and reactive q_dt load forecasts, which may differ from one time period to the next. In each time period t in T, we must determine the 'base-case' active power generation level of generator g in G, denoted by p^0_gt. The active power generations in consecutive time periods are constrained by the generator's ramping capacity, which can be modeled as follows:","category":"page"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"-r_g leq p^0_gt-1 - p^0_gt leq r_g qquad forall g in G  forall t in T setminus 1","category":"page"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"Here, r_g denotes the ramping capacity of generator g (per unit of time in which T is defined).","category":"page"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"For numerical convergence reasons, ProxAL implements the ramping constraint by introducing additional continuous variables s_gt and z_gt along with the following constraints. Note that a penalty term θ_t z^2 is also added to the objective function, where the parameter θ_t is controlled within ProxAL, see Algorithm parameters.","category":"page"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"leftbeginaligned\n    0 leq s_gt leq 2r_g  \n    p^0_gt-1 - p^0_gt + s_gt + z_gt = r_g\nendalignedright qquad forall g in G  forall t in T setminus 1","category":"page"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"For convenience, ProxAL also provides the functionality to solve the full/\"non-decomposed\" model using JuMP/Ipopt. In this case, one can switch between the inequality and penalty forms of the ramping constraint by setting the time_link_constr_type field of ProxAL.ModelParams in Model parameters. When solving the full/\"non-decomposed\" model with the penalty form of the ramping constraints, the user must provide a value for the parameter θ_t by setting θ_t in Algorithm parameters.","category":"page"},{"location":"man/formulation.html#Contingency-constraints","page":"Formulation","title":"Contingency constraints","text":"","category":"section"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"Each single-period ACOPF problem may itself be constrained further by a set of transmission line contingencies, denoted by K. The active and reactive power generations, and bus voltages must satisfy the following constraints in each time period and each contingency:","category":"page"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"the power flow equations, \nbounds on active and reactive generation and voltage magnitudes, and \nline power flow limits.","category":"page"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"It is possible that the problem parameters are such that (some of) the above constraints can become infeasible. To model this, ProxAL also allows constraint infeasibility (except on variable bounds) by penalizing them in the objective function.","category":"page"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"The contingencies in each time period are linked together via their active power generations in one of several forms. The choice of the form can be set using the ctgs_link_constr_type field of ProxAL.ModelParams in Model parameters.","category":"page"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"Preventive mode: active power generation in contingency k must be equal to the base case value. This constraint has one of two forms:  \nPreventive equality: This is the original form of the constraint. For numerical convergence reasons, ProxAL does not allow using this form whenever the decompCtgs field of ProxAL.AlgParams is set to true,  see Algorithm parameters.\np_gt^k = p_gt^0 qquad forall g in G  forall k in K  forall t in T\nPreventive penalty: In this form, ProxAL introduces additional continuous variables z_gkt along with the following constraints. Note that a penalty term θ_c z_k ^2 is also added to the objective function, where the parameter θ_c is controlled within ProxAL whenever the decompCtgs field of ProxAL.AlgParams is set to true. Otherwise, its value can be set using the θ_c field of ProxAL.AlgParams in Algorithm parameters.\np_gt^k = p_gt^0 + z_gkt qquad forall g in G  forall k in K  forall t in T\nCorrective mode: active power generation is allowed to deviate from base case by up to 10% of its ramping capacity. This constraint has one of two forms:   \nCorrective inequality: This is the original form of the constraint. For numerical convergence reasons, ProxAL does not allow using this form whenever the decompCtgs field of ProxAL.AlgParams is set to true, see Algorithm parameters.\n01 r_g leq p_gt^k - p_gt^0 leq 01  r_g qquad forall g in G  forall k in K  forall t in T\nCorrective equality: In this form, ProxAL introduces additional continuous variables s_gkt along with the following constraints. As before, ProxAL does not allow using this form whenever the decompCtgs field of ProxAL.AlgParams is set to true.\nleftbeginaligned\n  0 leq s_gkt leq 02 r_g  \n  p_gt^0 - p_gt^k + s_gkt = 01  r_g \n  endalignedright qquad forall g in G  forall k in K  forall t in T\nCorrective penalty: In this form, ProxAL introduces additional continuous variables s_gkt and z_gkt along with the following constraints. A penalty term θ_c z_k  ^2 is also added to the objective function, where the parameter θ_c is controlled within ProxAL whenever the decompCtgs field of ProxAL.AlgParams is set to true. Otherwise, its value can be set using the θ_c field of ProxAL.AlgParams in Algorithm parameters.\nleftbeginaligned\n    0 leq s_gkt leq 02 r_g  \n    p_gt^0 - p_gt^k + s_gkt + z_gkt = 01  r_g\nendalignedright qquad forall g in G  forall k in K  forall t in T\nFrequency control mode: In this case, ProxAL defines new continuous variables omega_kt which is the (deviation from nominal) system frequency in contingency k of time period t, and alpha_g is the droop control parameter of generator g. There is only one form of representing this constraint. The objective functions includes an additional term w_omega  omega ^2, where the parameter w_omega must be set using the weight_freq_ctrl field of ProxAL.ModelParams in Model parameters.","category":"page"},{"location":"man/formulation.html","page":"Formulation","title":"Formulation","text":"p_gt^k = p_gt^0 + alpha_g omega_kt qquad forall g in G  forall k in K  forall t in T","category":"page"},{"location":"man/algorithm.html#Algorithm","page":"Algorithm","title":"Algorithm","text":"","category":"section"},{"location":"man/algorithm.html","page":"Algorithm","title":"Algorithm","text":"The Formulation is decomposed into smaller optimization blocks. Specifically, ProxAL.jl supports decomposition into:","category":"page"},{"location":"man/algorithm.html","page":"Algorithm","title":"Algorithm","text":"single-period multiple-contingency ACOPF problems, and \nsingle-period single-contingency ACOPF problems.","category":"page"},{"location":"man/algorithm.html","page":"Algorithm","title":"Algorithm","text":"This decomposition is achieved by formulating an Augmented Lagrangian with respect to the coupling constraints: in decomposition mode 1, these are the ramping constraints; and in mode 2, these are the ramping as well as contingency-linking constraints.","category":"page"},{"location":"man/algorithm.html","page":"Algorithm","title":"Algorithm","text":"The decomposed formulation is solved using an iterative ADMM-like Jacobi scheme with proximal terms, by updating first the primal variables (e.g., power generations and voltages) and then the dual variables of the coupling constraints. The Jacobi nature of the update implies that the single-block nonlinear programming (NLP) problems can be solved in parallel. ProxAL.jl allows the parallel solution of these NLP block subproblems using the MPI.jl package.","category":"page"},{"location":"lib/algparams.html","page":"Algorithm parameters","title":"Algorithm parameters","text":"CurrentModule = ProxAL","category":"page"},{"location":"lib/algparams.html#Algorithm-parameters","page":"Algorithm parameters","title":"Algorithm parameters","text":"","category":"section"},{"location":"lib/algparams.html#Description","page":"Algorithm parameters","title":"Description","text":"","category":"section"},{"location":"lib/algparams.html","page":"Algorithm parameters","title":"Algorithm parameters","text":"AlgParams","category":"page"},{"location":"lib/algparams.html#ProxAL.AlgParams","page":"Algorithm parameters","title":"ProxAL.AlgParams","text":"AlgParams\n\nSpecifies ProxAL's algorithmic parameters.\n\nParameter Description Default value\ndecompCtgs::Bool if true: decompose across contingencies (along with time) false\njacobi::Bool if true: do Jacobi updates, else do Gauss-Siedel updates true\niterlim::Int maximum number of ProxAL iterations 100\nnlpiterlim::Int maximum number of NLP subproblem iterations 100\ntol::Float64 tolerance used for ProxAL termination 1.0e-4\nzero::Float64 tolerance below which is regarded as zero 1.0e-8\nθ_t::Float64 see Formulation 1.0\nθ_c::Float64 see Formulation 1.0\nρ_t::Float64 AL penalty weight for ramp constraints 1.0\nρ_c::Float64 AL penalty weight for ctgs constraints 1.0\nupdateρ_t::Bool if true: dynamically update ρ_t true\nupdateρ_c::Bool if true: dynamically update ρ_c true\nτ::Float64 Proximal weight parameter 3.0\nupdateτ::Bool if true: dynamically update τ true\nverbose::Int level of output: 0 (none), 1 (stdout) 0\nmode::Symbol computation mode ∈ [:nondecomposed, :coldstart, :lyapunov_bound] :coldstart\noptimizer::Any NLP solver nothing\ngpu_optimizer::Any GPU-compatible NLP solver nothing\nnr_tol::Float64 Tolerance of the Newton-Raphson algorithm (used only in ExaPFBackend() model) 1e-10\ninit_opt::Bool if true: initialize block OPFs with base OPF solution false\ndevice::TargetDevice Target device to deport the resolution of the optimization problem CPU\n\n\n\n\n\n","category":"type"},{"location":"lib/algorithm.html","page":"Main functions","title":"Main functions","text":"CurrentModule = ProxAL","category":"page"},{"location":"lib/algorithm.html#Main-functions","page":"Main functions","title":"Main functions","text":"","category":"section"},{"location":"lib/algorithm.html#API-Reference","page":"Main functions","title":"API Reference","text":"","category":"section"},{"location":"lib/algorithm.html","page":"Main functions","title":"Main functions","text":"ProxALEvaluator\nNonDecomposedModel\noptimize!(::ProxALEvaluator)\noptimize!(::NonDecomposedModel)","category":"page"},{"location":"lib/algorithm.html#ProxAL.ProxALEvaluator","page":"Main functions","title":"ProxAL.ProxALEvaluator","text":"ProxALEvaluator(\n    case_file::String,\n    load_file::String,\n    modelinfo::ModelParams,\n    algparams::AlgParams,\n    space::AbstractSpace=JuMPBackend(),\n    comm::MPI.Comm = MPI.COMM_WORLD)\n\nInstantiate multi-period ACOPF specified in case_file with loads in load_file with model parameters modelinfo, algorithm parameters algparams, modeling backend space, and a MPI communicator comm.\n\n\n\n\n\n","category":"type"},{"location":"lib/algorithm.html#ProxAL.NonDecomposedModel","page":"Main functions","title":"ProxAL.NonDecomposedModel","text":"NonDecomposedModel(\n    case_file::String,\n    load_file::String,\n    modelinfo::ModelParams,\n    algparams::AlgParams,\n    space::AbstractSpace=JuMPBackend(),\n    comm::MPI.Comm = MPI.COMM_WORLD\n)\n\nInstantiate non-decomposed multi-period ACOPF instance specified in case_file with loads in load_file with model parameters modelinfo and algorithm parameters algparams, and a MPI communicator comm.\n\n\n\n\n\n","category":"type"},{"location":"lib/algorithm.html#ProxAL.optimize!-Tuple{ProxALEvaluator}","page":"Main functions","title":"ProxAL.optimize!","text":"optimize!(nlp::ProxALEvaluator)\n\nSolve problem using the nlp evaluator of the decomposition algorithm.\n\n\n\n\n\n","category":"method"},{"location":"lib/algorithm.html#ProxAL.optimize!-Tuple{NonDecomposedModel}","page":"Main functions","title":"ProxAL.optimize!","text":"optimize!(nlp::NonDecomposedModel)\n\nSolve problem using the nlp evaluator of the nondecomposed model.\n\n\n\n\n\n","category":"method"},{"location":"man/usage.html#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"man/usage.html","page":"Usage","title":"Usage","text":"ProxAL.jl can be called from existing Julia code or REPL, or also from the terminal.","category":"page"},{"location":"man/usage.html","page":"Usage","title":"Usage","text":"note: Note\nTo do: Update documentation to show how to use ExaTron, ExaPF backends, as well as other solvers like MadNLP.","category":"page"},{"location":"man/usage.html#Julia-code-or-REPL","page":"Usage","title":"Julia code or REPL","text":"","category":"section"},{"location":"man/usage.html","page":"Usage","title":"Usage","text":"Install ProxAL.jl via the Julia package manager (type ]):","category":"page"},{"location":"man/usage.html","page":"Usage","title":"Usage","text":"pkg> add git@github.com:exanauts/ProxAL.jl.git\npkg> test ProxAL","category":"page"},{"location":"man/usage.html","page":"Usage","title":"Usage","text":"Next, set up and solve the problem as follows. Note that all case files are stored in the data/ subdirectory. For a full list of model and algorithmic options, see Model parameters and Algorithm parameters.","category":"page"},{"location":"man/usage.html","page":"Usage","title":"Usage","text":"Consider the following example.jl using the JuMP backend, Ipopt solver, and MPI:","category":"page"},{"location":"man/usage.html","page":"Usage","title":"Usage","text":"using ProxAL\nusing JuMP, Ipopt\nusing MPI\n\nMPI.Init()\n\n# Model/formulation settings\nmodelinfo = ModelParams()\nmodelinfo.case_name = \"case9\"\nmodelinfo.num_time_periods = 2\nmodelinfo.num_ctgs = 1\nmodelinfo.weight_freq_ctrl = 0.1\nmodelinfo.time_link_constr_type = :penalty\nmodelinfo.ctgs_link_constr_type = :frequency_ctrl\n\n# Load case in MATPOWER format\ncase_file = \"data/$(modelinfo.case_name).m\"\nload_file = \"data/mp_demand/$(modelinfo.case_name)_oneweek_168\"\n\n# Algorithm settings\nalgparams = AlgParams()\nalgparams.optimizer = JuMP.optimizer_with_attributes(Ipopt.Optimizer, \"print_level\" => 0)\nalgparams.decompCtgs = false\nalgparams.verbose = 1\n\nnlp = ProxALEvaluator(case_file, load_file, modelinfo, algparams, JuMPBackend())\nruninfo = ProxAL.optimize!(nlp)","category":"page"},{"location":"man/usage.html","page":"Usage","title":"Usage","text":"To execute this file with 2 MPI processes, you can call","category":"page"},{"location":"man/usage.html","page":"Usage","title":"Usage","text":"mpiexec -n 2 julia --project=. example.jl","category":"page"},{"location":"index.html#ProxAL","page":"Home","title":"ProxAL","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"ProxAL.jl is a Julia package to solve multiperiod contingency-constrained AC Optimal Power Flow (ACOPF) problems. Its main feature is a distributed parallel implementation, which allows running on high-performance computing architectures. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This document describes the algorithm, API and main functions of ProxAL.jl.","category":"page"},{"location":"index.html#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"index.html#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"man/formulation.md\",\n    \"man/algorithm.md\",\n    \"man/usage.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Library","page":"Home","title":"Library","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"lib/modelparams.md\",\n    \"lib/algparams.md\",\n    \"lib/algorithm.md\",\n    \"lib/developer.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This research was supported by the Exascale Computing Project, a joint project of the U.S. Department of Energy’s Office of Science and National Nuclear Security Administration.","category":"page"},{"location":"lib/modelparams.html","page":"Model parameters","title":"Model parameters","text":"CurrentModule = ProxAL","category":"page"},{"location":"lib/modelparams.html#Model-parameters","page":"Model parameters","title":"Model parameters","text":"","category":"section"},{"location":"lib/modelparams.html#Description","page":"Model parameters","title":"Description","text":"","category":"section"},{"location":"lib/modelparams.html","page":"Model parameters","title":"Model parameters","text":"ModelParams","category":"page"},{"location":"lib/modelparams.html#ProxAL.ModelParams","page":"Model parameters","title":"ProxAL.ModelParams","text":"ModelParams\n\nSpecifies the ACOPF model structure.\n\nParameter Description Default value\nnum_time_periods::Int number of time periods 1\nnum_ctgs::Int number of line contingencies 0\nload_scale::Float64 load multiplication factor 1.0\nramp_scale::Float64 multiply this with p_g^max to get generator ramping r_g 1.0\nobj_scale::Float64 objective multiplication factor 1.0e-3\nallow_obj_gencost::Bool model generator cost true\nallow_constr_infeas::Bool allow constraint infeasibility false\nweight_constr_infeas::Float64 quadratic penalty weight for constraint infeasibilities 1.0\nweight_freq_ctrl::Float64 quadratic penalty weight for frequency violations 1.0\nweight_ctgs::Float64 linear weight of contingency objective function 1.0\ncase_name::String name of case file \"\"\nsavefile::String name of save file \"\"\ntime_link_constr_type::Symbol ∈ [:penalty, :equality, :inequality] see Formulation :penalty\nctgs_link_constr_type::Symbol ∈ [:frequency_ctrl, :preventive_penalty, :preventive_equality, :corrective_penalty, :corrective_equality, :corrective_inequality], see Formulation :frequency_ctrl\n\n\n\n\n\n","category":"type"}]
}
