<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quick start · ExaPF.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ExaPF.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li class="is-active"><a class="tocitem" href="quickstart.html">Quick start</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="man/autodiff.html">AutoDiff</a></li><li><a class="tocitem" href="man/linearsolver.html">Linear Solver</a></li><li><a class="tocitem" href="man/powersystem.html">PowerSystem</a></li><li><a class="tocitem" href="man/formulations.html">Formulations</a></li><li><a class="tocitem" href="man/evaluators.html">Evaluators</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="lib/autodiff.html">AutoDiff</a></li><li><a class="tocitem" href="lib/linearsolver.html">Linear Solver</a></li><li><a class="tocitem" href="lib/powersystem.html">PowerSystem</a></li><li><a class="tocitem" href="lib/formulations.html">Formulations</a></li><li><a class="tocitem" href="lib/evaluators.html">Evaluators</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="quickstart.html">Quick start</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="quickstart.html">Quick start</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/exanauts/ExaPF.jl/blob/master/docs/src/quickstart.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Quick-Start"><a class="docs-heading-anchor" href="#Quick-Start">Quick Start</a><a id="Quick-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start" title="Permalink"></a></h1><p>This page introduces the first steps to set up <code>ExaPF.jl</code>. We show how to load a power network instance and how to solve the power flow equations both on the CPU and on the GPU.</p><h3 id="How-to-load-a-Matpower-instance?"><a class="docs-heading-anchor" href="#How-to-load-a-Matpower-instance?">How to load a Matpower instance?</a><a id="How-to-load-a-Matpower-instance?-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-load-a-Matpower-instance?" title="Permalink"></a></h3><p>We start by importing into <code>ExaPF</code> an instance specified in the Matpower format.</p><p>First, you could load the package with</p><pre><code class="language-julia-repl">julia&gt; using ExaPF
julia&gt; const PS = ExaPF.PowerSystem</code></pre><p>Imagine you want to load an instance from the <a href="https://github.com/power-grid-lib/pglib-opf"><code>pglib-opf</code></a> benchmark, stored in the current folder:</p><pre><code class="language-julia-repl">julia&gt; pglib_instance = &quot;pglib_opf_case1354_pegase.m&quot;</code></pre><p><code>ExaPF.jl</code> allows you to load directly the instance as a <code>PowerNetwork</code> object:</p><pre><code class="language-julia-repl">julia&gt; pf = PS.PowerNetwork(pglib_instance, 1)</code></pre><p>The different fields of the object <code>pf</code> specify the characteristics of the network. For instance, we could retrieve the number of buses or get the indexing of the PV buses with</p><pre><code class="language-julia-repl">julia&gt; nbus = pf.nbus
1354
julia&gt; pv_indexes = PS.get(pf, PS.PVIndexes())
[17, 21, ..., 1344]</code></pre><p>However, a <code>PowerNetwork</code> object stores only the <strong>physical</strong> attributes of the network, independently from the mathematical formulations we could use to model the network. To choose a particular formulation, we need to pass the object <code>pf</code> to a <code>AbstractFormulation</code> layer. Currently, the only layer implemented is the polar formulation, with the <code>PolarForm</code> abstraction. In the future, other formulations (e.g. <code>RectangularForm</code>) may be implemented as well.</p><h3 id="How-to-solve-the-powerflow-equations?"><a class="docs-heading-anchor" href="#How-to-solve-the-powerflow-equations?">How to solve the powerflow equations?</a><a id="How-to-solve-the-powerflow-equations?-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-solve-the-powerflow-equations?" title="Permalink"></a></h3><p>To solve the powerflow equations, we need to choose a given mathematical formulation for the equations of the network. To each formulation corresponds a given state <span>$x$</span> and control <span>$u$</span>. The powerflow equations write in the abstract mathematical formalism:</p><div>\[g(x, u) = 0.\]</div><p>For a given control <span>$u$</span>, solving the powerflow equations resumes to find a state <span>$x(u)$</span> such that <span>$g(x(u), u) = 0$</span>. To this goal, <code>ExaPF.jl</code> implements a Newton-Raphson algorithm.</p><p>We first instantiate a <code>PolarForm</code> object to adopt a polar formulation as a model:</p><pre><code class="language-julia-repl">julia&gt; polar = PolarForm(pf, CPU())
</code></pre><p>Note that the constructor <code>PolarForm</code> takes as input a <code>PowerNetwork</code> object and a <code>KernelAbstractions.jl</code> device (here set to <code>CPU()</code> by default). We will explain in the next section how to load a <code>PolarForm</code> object on the GPU with the help of a <code>CUDADevice</code>.</p><p>The Newton-Raphson solves the equation <span>$g(x, u) = 0$</span> in an iterative fashion. The algorithm solves at each step the linear equation:</p><div>\[    x_{k+1} = - (\nabla_x g_k)^{-1} g(x_k, u).\]</div><p>Hence, the algorithm requires the following elements:</p><ul><li>an initial position <span>$x_0$</span></li><li>a function to evaluate the Jacobian <span>$\nabla_x g_k$</span></li><li>a function to solve efficiently the linear system <span>$(\nabla_x g_k) x_{k+1} = g(x_k, u)$</span></li></ul><p>that translate to the Julia code:</p><pre><code class="language-julia-repl">julia&gt; physical_state = get(polar, PhysicalState())
julia&gt; jx = ExaPF.init_ad_factory(polar, physical_state)
julia&gt; linear_solver = DirectSolver()
</code></pre><p>Let&#39;s explain further these three objects.</p><ul><li><code>physical_state</code> is a <code>AbstractPhysicalCache</code> storing all the physical values attached to the formulation <code>polar::PolarForm</code>.</li><li><code>jx</code> is a <code>StateJacobianAD</code> which allows the solver to compute efficiently by automatic differentiation the Jacobian of the powerflow equations <span>$\nabla_x g$</span>.</li><li><code>linear_solver</code> specifies the linear algorithm uses to solve the linear system <span>$(\nabla_x g_k) x_{k+1} = g(x_k, u)$</span>. By default, we use direct linear algebra.</li></ul><p>Then, we could solve the powerflow equations simply with</p><pre><code class="language-julia-repl">julia&gt; convergence = ExaPF.powerflow(polar, jx, physical_state,
                                     linear_solver=linear_solver,
                                     verbose_level=1)
Iteration 0. Residual norm: 26.6667.
Iteration 1. Residual norm: 15.0321.
Iteration 2. Residual norm: 0.588264.
Iteration 3. Residual norm: 0.00488507.
Iteration 4. Residual norm: 1.39924e-06.
Iteration 5. Residual norm: 7.37136e-12.</code></pre><p>Here, the algorithm solves the powerflow equations in 5 iterations. The algorithm modifies the values of <code>physical_state</code> inplace, to avoid any unnecessary memory allocations.</p><h3 id="How-to-deport-the-computation-on-the-GPU?"><a class="docs-heading-anchor" href="#How-to-deport-the-computation-on-the-GPU?">How to deport the computation on the GPU?</a><a id="How-to-deport-the-computation-on-the-GPU?-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-deport-the-computation-on-the-GPU?" title="Permalink"></a></h3><p>Now, what if we want to deport the resolution on the GPU? The procedure looks exactly the same. It suffices to initiate a new <code>PolarForm</code> object, but on the GPU:</p><pre><code class="language-julia-repl">julia&gt; polar_gpu = PolarForm(pf, CUDADevice())
</code></pre><p><code>polar_gpu</code> will load all the structure it needs on the GPU, to avoid unnecessary movements between the host and the GPU. We could load the other structures directly on the GPU with:</p><pre><code class="language-julia-repl">julia&gt; physical_state_gpu = get(polar, PhysicalState())
julia&gt; jx_gpu = ExaPF.init_ad_factory(polar, physical_state)
julia&gt; linear_solver = DirectSolver()
</code></pre><p>and then, solving the powerflow equations on the GPU is straightforward:</p><pre><code class="language-julia-repl">julia&gt; convergence = ExaPF.powerflow(polar_gpu, jx_gpu, physical_state_gpu,
                                     linear_solver=linear_solver,
                                     verbose_level=1)
Iteration 0. Residual norm: 26.6667.
Iteration 1. Residual norm: 15.0321.
Iteration 2. Residual norm: 0.588264.
Iteration 3. Residual norm: 0.00488507.
Iteration 4. Residual norm: 1.39924e-06.
Iteration 5. Residual norm: 7.94916e-12.</code></pre><p>Note that we get the same convergence pattern as on the CPU.</p><h3 id="How-to-solve-the-linear-system-with-BICGSTAB?"><a class="docs-heading-anchor" href="#How-to-solve-the-linear-system-with-BICGSTAB?">How to solve the linear system with BICGSTAB?</a><a id="How-to-solve-the-linear-system-with-BICGSTAB?-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-solve-the-linear-system-with-BICGSTAB?" title="Permalink"></a></h3><p>By default, the algorithm runs with a direct solver, which might be inefficient for large problems. We might want to use an iterative solver instead. <code>ExaPF.jl</code> allows to use a block-Jacobi preconditioner:</p><pre><code class="language-julia-repl">julia&gt; const LS = ExaPF.LinearSolvers
julia&gt; npartitions = 8
julia&gt; precond = LS.BlockJacobiPreconditioner(jac, npartitions, CUDADevice())</code></pre><p>The iterative linear solver is instantiated with:</p><pre><code class="language-julia-repl">julia&gt; linear_solver = ExaPF.BICGSTAB(precond)
</code></pre><p>By default, the tolerance of BICGSTAB is set to <code>1e-8</code>:</p><pre><code class="language-julia-repl">julia&gt; linear_solver.tol
1e-8</code></pre><p>We need to update accordingly the tolerance of the Newton-Raphson algorithm, as it could not be lower than the tolerance of the iterative solver.</p><pre><code class="language-julia-repl">julia&gt; convergence = ExaPF.powerflow(polar_gpu, jx_gpu, physical_state_gpu,
                                     linear_solver=linear_solver,
                                     tol=1e-7,
                                     verbose_level=1)
Iteration 0. Residual norm: 26.6667.
Iteration 1. Residual norm: 15.0321.
Iteration 2. Residual norm: 0.588264.
Iteration 3. Residual norm: 0.00488507.
Iteration 4. Residual norm: 1.39925e-06.
Iteration 5. Residual norm: 1.81445e-09.
</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Home</a><a class="docs-footer-nextpage" href="man/autodiff.html">AutoDiff »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 1 October 2020 15:57">Thursday 1 October 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
