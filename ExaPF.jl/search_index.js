var documenterSearchIndex = {"docs":
[{"location":"formulations.html","page":"Formulations","title":"Formulations","text":"CurrentModule = ExaPF\r\nDocTestSetup = quote\r\n    using ExaPF\r\nend\r\nDocTestFilters = [r\"ExaPF\"]","category":"page"},{"location":"formulations.html#Formulations","page":"Formulations","title":"Formulations","text":"","category":"section"},{"location":"formulations.html#Description","page":"Formulations","title":"Description","text":"","category":"section"},{"location":"formulations.html","page":"Formulations","title":"Formulations","text":"AbstractFormulation\r\n","category":"page"},{"location":"formulations.html#ExaPF.AbstractFormulation","page":"Formulations","title":"ExaPF.AbstractFormulation","text":"AbstractFormulation\n\nSecond layer of the package, implementing the interface between the first layer (the topology of the network) and the third layer (implementing the callbacks for the optimization solver).\n\n\n\n\n\n","category":"type"},{"location":"formulations.html#API-Reference","page":"Formulations","title":"API Reference","text":"","category":"section"},{"location":"formulations.html#Variables","page":"Formulations","title":"Variables","text":"","category":"section"},{"location":"formulations.html","page":"Formulations","title":"Formulations","text":"AbstractVariable\r\nState\r\nControl\r\nParameters\r\n","category":"page"},{"location":"formulations.html#ExaPF.AbstractVariable","page":"Formulations","title":"ExaPF.AbstractVariable","text":"AbstractVariable\n\nVariables corresponding to a particular formulation.\n\n\n\n\n\n","category":"type"},{"location":"formulations.html#ExaPF.State","page":"Formulations","title":"ExaPF.State","text":"State <: AbstractVariable\n\nAll variables x depending on the variables Control u through a non-linear equation g(x, u) = 0.\n\n\n\n\n\n","category":"type"},{"location":"formulations.html#ExaPF.Control","page":"Formulations","title":"ExaPF.Control","text":"Control <: AbstractVariable\n\nImplement the independent variables used in the reduced-space formulation.\n\n\n\n\n\n","category":"type"},{"location":"formulations.html#ExaPF.Parameters","page":"Formulations","title":"ExaPF.Parameters","text":"Parameters <: AbstractVariable\n\nConstant parameters.\n\n\n\n\n\n","category":"type"},{"location":"formulations.html","page":"Formulations","title":"Formulations","text":"Get default values attached to a given variable:","category":"page"},{"location":"formulations.html","page":"Formulations","title":"Formulations","text":"initial\r\n","category":"page"},{"location":"formulations.html#ExaPF.initial","page":"Formulations","title":"ExaPF.initial","text":"initial(form::AbstractFormulation, var::AbstractVariable)\n\nReturn an initial position for the variable var.\n\nExamples\n\nu₀ = initial(form, Control())\nx₀ = initial(form, State())\n\n\n\n\n\n\n","category":"function"},{"location":"formulations.html#Powerflow-solver","page":"Formulations","title":"Powerflow solver","text":"","category":"section"},{"location":"formulations.html","page":"Formulations","title":"Formulations","text":"powerflow\r\n","category":"page"},{"location":"formulations.html#ExaPF.powerflow","page":"Formulations","title":"ExaPF.powerflow","text":"powerflow(form::AbstractFormulation,\n          jacobian::AD.StateJacobianAD,\n          x::VT,\n          u::VT,\n          p::VT;\n          kwargs...) where VT <: AbstractVector\n\nSolve the power flow equations g(x, u) = 0 w.r.t. the state x, using a Newton-Raphson algorithm. The power flow equations are specified in the formulation form. The solution x(u) depends on the control u passed in input.\n\nThe algorithm stops when a tolerance tol or a maximum number of irations maxiter are reached.\n\nArguments\n\nform::AbstractFormulation: formulation of the power flow equation\nx::AbstractVector: initial state (the value of x is kept constant)\nu::AbstractVector: fixed control (the control is determined by the formulation used)\np::AbstractVector: fixed parameters (also dependent on the formulation used)\n\nOptional arguments\n\ntol::Float64 (default 1e-7): tolerance of the Newton-Raphson algorithm.\nmaxiter::Int (default 20): maximum number of iterations.\nverbose_level::Int (default O, max value: 3): verbose level\n\n\n\n\n\n","category":"function"},{"location":"formulations.html#Constraints","page":"Formulations","title":"Constraints","text":"","category":"section"},{"location":"formulations.html","page":"Formulations","title":"Formulations","text":"state_constraints\r\npower_constraints\r\nthermal_limit_constraints\r\n","category":"page"},{"location":"formulations.html#ExaPF.state_constraints","page":"Formulations","title":"ExaPF.state_constraints","text":"state_constraints(form::AbstractFormulation, g::VT, x::VT, u::VT, p::VT) where {VT<:AbstractVector}\n\nEvaluate the constraints porting on the state x, as a function of x and u. The result is stored inplace, inside g.\n\n\n\n\n\n","category":"function"},{"location":"formulations.html#ExaPF.power_constraints","page":"Formulations","title":"ExaPF.power_constraints","text":"power_constraints(form::AbstractFormulation, g::VT, x::VT, u::VT, p::VT) where {VT<:AbstractVector}\n\nEvaluate the constraints on the power production that are not taken into account in\n\nthe box constraints on the control u\nthe box constraints on the state x (implemented in state_constraints)\n\nThe result is stored inplace, inside g.\n\n\n\n\n\n","category":"function"},{"location":"formulations.html#ExaPF.thermal_limit_constraints","page":"Formulations","title":"ExaPF.thermal_limit_constraints","text":"thermal_limit_constraints(form::AbstractFormulation, g::VT, x::VT, u::VT, p::VT) where {VT<:AbstractVector}\n\nEvaluate the thermal limit constraints porting on the lines of the network.\n\nThe result is stored inplace, inside the vector g.\n\n\n\n\n\n","category":"function"},{"location":"formulations.html","page":"Formulations","title":"Formulations","text":"Admissible range for variables and constraints:","category":"page"},{"location":"formulations.html","page":"Formulations","title":"Formulations","text":"bounds","category":"page"},{"location":"formulations.html#ExaPF.bounds","page":"Formulations","title":"ExaPF.bounds","text":"bounds(form::AbstractFormulation, var::AbstractVariable)\n\nReturn the bounds attached to the variable var.\n\nbounds(form::AbstractFormulation, func::Function)\n\nReturn the lower and upper bounds attached to a given constraint functional.\n\nExamples\n\nu_min, u_max = bounds(form, Control())\nh_min, h_max = bounds(form, power_constraints)\n\n\n\n\n\n\n","category":"function"},{"location":"formulations.html#Costs","page":"Formulations","title":"Costs","text":"","category":"section"},{"location":"formulations.html","page":"Formulations","title":"Formulations","text":"cost_production","category":"page"},{"location":"formulations.html#ExaPF.cost_production","page":"Formulations","title":"ExaPF.cost_production","text":"cost_production(form::AbstractFormulation, x, u, p)::Float64\n\nGet operational cost for given state x and control u.\n\n\n\n\n\n","category":"function"},{"location":"formulations.html#Attributes","page":"Formulations","title":"Attributes","text":"","category":"section"},{"location":"formulations.html","page":"Formulations","title":"Formulations","text":"AbstractFormAttribute\r\nNumberOfState\r\nNumberOfControl\r\n","category":"page"},{"location":"formulations.html#ExaPF.AbstractFormAttribute","page":"Formulations","title":"ExaPF.AbstractFormAttribute","text":"AbstractFormAttribute\n\nAttributes attached to an AbstractFormulation.\n\n\n\n\n\n","category":"type"},{"location":"formulations.html#ExaPF.NumberOfState","page":"Formulations","title":"ExaPF.NumberOfState","text":"Number of states attached to a particular formulation.\n\n\n\n\n\n","category":"type"},{"location":"formulations.html#ExaPF.NumberOfControl","page":"Formulations","title":"ExaPF.NumberOfControl","text":"Number of controls attached to a particular formulation.\n\n\n\n\n\n","category":"type"},{"location":"linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"CurrentModule = ExaPF\r\nDocTestSetup = quote\r\n    using ExaPF\r\n    const Precondition = ExaPF.Precondition\r\n    const Iterative = ExaPF.Iterative\r\nend\r\nDocTestFilters = [r\"ExaPF\"]","category":"page"},{"location":"linearsolver.html#Linear-Solver","page":"Linear Solver","title":"Linear Solver","text":"","category":"section"},{"location":"linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"As mentioned before, a linear solver is required to compute the Newton step in ","category":"page"},{"location":"linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"dx .= jacobian(x)\\f(x)","category":"page"},{"location":"linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"Our package supports the following linear solvers:","category":"page"},{"location":"linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"CUSOLVER with csrlsvqr (GPU),\nKrylov.jl with dqgmres (CPU/GPU), \nIterativeSolvers.jl with bicgstab (CPU),\nUMFPACK through the default Julia \\ operator (CPU),\nand a generic BiCGSTAB implementation [Vorst1992] (CPU/GPU).","category":"page"},{"location":"linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"The last custom implementation was necessary as BiCGSTAB showed much better performance than GMRES and at the time of this writing both Krylov.jl and IterativeSolvers.jl did not provide an implementation that supported CUDA.jl.","category":"page"},{"location":"linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"Using only an iterative solver lead to divergence and bad performance due to ill-conditioning of the Jacobian. This is a known phenomenon in power systems. That's why this package comes with a block Jacobi preconditioner that is tailored towards GPUs and is proven to work well with power flow problems.","category":"page"},{"location":"linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"The Jacobian is partitioned into a dense block diagonal structure, where each block is inverted to build our preconditioner P. For the partition we use Metis.jl.","category":"page"},{"location":"linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"(Image: Dense block Jacobi preconditioner \\label{fig:preconditioner})","category":"page"},{"location":"linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"Compared to incomplete Cholesky and incomplete LU this preconditioner is easily portable to the GPU if the number of blocks is high enough. ExaPF.jl uses the batch BLAS calls from CUBLAS to invert the single blocks.","category":"page"},{"location":"linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"CUDA.@sync pivot, info = CUDA.CUBLAS.getrf_batched!(blocks, true)\r\nCUDA.@sync pivot, info, p.cuJs = CUDA.CUBLAS.getri_batched(blocks, pivot)","category":"page"},{"location":"linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"Assuming that other vendors will provide such batched BLAS APIs, this code is portable to other GPU architectures.","category":"page"},{"location":"linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"[Vorst1992]: Vorst, H. A. van der. 1992. “Bi-Cgstab: A Fast and Smoothly ConvergingVariant of Bi-Cg for the Solution of Nonsymmetric Linear Systems.”SIAMJournal on Scientific and Statistical Computing13 (2):  631–44","category":"page"},{"location":"linearsolver.html#Description","page":"Linear Solver","title":"Description","text":"","category":"section"},{"location":"linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"Precondition.AbstractPreconditioner","category":"page"},{"location":"linearsolver.html#ExaPF.Precondition.AbstractPreconditioner","page":"Linear Solver","title":"ExaPF.Precondition.AbstractPreconditioner","text":"AbstractPreconditioner\n\nPreconditioners for the iterative solvers mostly focused on GPUs \n\n\n\n\n\n","category":"type"},{"location":"linearsolver.html#API-Reference","page":"Linear Solver","title":"API Reference","text":"","category":"section"},{"location":"linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"Precondition.Preconditioner\r\nPrecondition.update\r\nPrecondition.build_adjmatrix\r\nPrecondition.fillblock_gpu!\r\nPrecondition.fillP_gpu!","category":"page"},{"location":"linearsolver.html#ExaPF.Precondition.Preconditioner","page":"Linear Solver","title":"ExaPF.Precondition.Preconditioner","text":"Preconditioner\n\nCreates an object for the block-Jacobi preconditioner\n\nnpart::Int64: Number of partitions or blocks\nnJs::Int64: Size of the blocks. For the GPUs these all have to be of equal size.\npartitions::Vector{Vector{Int64}}:npart` partitions stored as lists\ncupartitions: partitions transfered to the GPU\nJs: Dense blocks of the block-Jacobi\ncuJs: Js transfered to the GPU\nmap: The partitions as a mapping to construct views \ncumap: cumap transferred to the GPU`\npart: Partitioning as output by Metis\ncupart: part transferred to the GPU\nP: The sparse precondition matrix whose values are updated at each iteration\n\n\n\n\n\n","category":"type"},{"location":"linearsolver.html#ExaPF.Precondition.update","page":"Linear Solver","title":"ExaPF.Precondition.update","text":"function update(J::CuSparseMatrixCSR, p, to)\n\nUpdate the preconditioner p from the sparse Jacobian J in CSR format for the GPU  \n\nThe dense blocks cuJs are filled from the sparse Jacobian J\nTo a batch inversion of the dense blocks using CUBLAS\nExtract the preconditioner matrix p.P from the dense blocks cuJs \n\n\n\n\n\nfunction update(J::CuSparseMatrixCSR, p, to)\n\nUpdate the preconditioner p from the sparse Jacobian J in CSC format for the CPU  \n\nNote that this implements the same algorithm as for the GPU and becomes very slow on CPU with growing number of blocks.\n\n\n\n\n\n","category":"function"},{"location":"linearsolver.html#ExaPF.Precondition.build_adjmatrix","page":"Linear Solver","title":"ExaPF.Precondition.build_adjmatrix","text":"build_adjmatrix\n\nBuild the adjacency matrix of a matrix A corresponding to the undirected graph\n\n\n\n\n\n","category":"function"},{"location":"linearsolver.html#ExaPF.Precondition.fillblock_gpu!","page":"Linear Solver","title":"ExaPF.Precondition.fillblock_gpu!","text":"fillblock_gpu\n\nFill the dense blocks of the preconditioner from the sparse CSC matrix arrays\n\n\n\n\n\n","category":"function"},{"location":"linearsolver.html#ExaPF.Precondition.fillP_gpu!","page":"Linear Solver","title":"ExaPF.Precondition.fillP_gpu!","text":"fillblock_gpu\n\nUpdate the values of the preconditioner matrix from the dense Jacobi blocks\n\n\n\n\n\n","category":"function"},{"location":"evaluators.html","page":"Evaluators","title":"Evaluators","text":"CurrentModule = ExaPF\r\nDocTestSetup = quote\r\n    using ExaPF\r\nend\r\nDocTestFilters = [r\"ExaPF\"]","category":"page"},{"location":"evaluators.html#Evaluators","page":"Evaluators","title":"Evaluators","text":"","category":"section"},{"location":"evaluators.html#Description","page":"Evaluators","title":"Description","text":"","category":"section"},{"location":"evaluators.html","page":"Evaluators","title":"Evaluators","text":"AbstractNLPEvaluator","category":"page"},{"location":"evaluators.html#ExaPF.AbstractNLPEvaluator","page":"Evaluators","title":"ExaPF.AbstractNLPEvaluator","text":"AbstractNLPEvaluator\n\nAbstractNLPEvaluator implements the bridge between the problem formulation (see AbstractFormulation) and the optimization solver. Once the problem formulation bridged, the evaluator allows to evaluate in a straightfoward fashion the objective and the different constraints, but also the corresponding gradient and Jacobian objects.\n\n\n\n\n\n","category":"type"},{"location":"evaluators.html","page":"Evaluators","title":"Evaluators","text":"When working in the reduced space, we could use the corresponding ReducedSpaceEvaluator:","category":"page"},{"location":"evaluators.html","page":"Evaluators","title":"Evaluators","text":"ReducedSpaceEvaluator","category":"page"},{"location":"evaluators.html#ExaPF.ReducedSpaceEvaluator","page":"Evaluators","title":"ExaPF.ReducedSpaceEvaluator","text":"ReducedSpaceEvaluator{T} <: AbstractNLPEvaluator\n\nEvaluator working in the reduced space corresponding to the control variable u. Once a new point u is passed to the evaluator, the user needs to call the method update! to find the corresponding state x(u) satisfying the equilibrium equation g(x(u), u) = 0.\n\nTaking as input a given AbstractFormulation, the reduced evaluator builds the bounds corresponding to the control u and the state x, and initiate an ADFactory tailored to the problem. The reduced evaluator could be instantiate on the main memory, or on a specific device (currently, only CUDA is supported).\n\n\n\n\n\n","category":"type"},{"location":"evaluators.html#API-Reference","page":"Evaluators","title":"API Reference","text":"","category":"section"},{"location":"evaluators.html","page":"Evaluators","title":"Evaluators","text":"n_variables\r\nn_constraints\r\nobjective\r\ngradient!\r\nconstraint!\r\njacobian_structure!\r\njacobian!\r\nhessian!\r\n","category":"page"},{"location":"evaluators.html#ExaPF.n_variables","page":"Evaluators","title":"ExaPF.n_variables","text":"n_variables(nlp::AbstractNLPEvaluator)\n\nGet the number of variables in the problem.\n\n\n\n\n\n","category":"function"},{"location":"evaluators.html#ExaPF.n_constraints","page":"Evaluators","title":"ExaPF.n_constraints","text":"n_constraints(nlp::AbstractNLPEvaluator)\n\nGet the number of constraints in the problem.\n\n\n\n\n\n","category":"function"},{"location":"evaluators.html#ExaPF.objective","page":"Evaluators","title":"ExaPF.objective","text":"objective(nlp::AbstractNLPEvaluator, u)::Float64\n\nEvaluate the objective at point u.\n\n\n\n\n\n","category":"function"},{"location":"evaluators.html#ExaPF.gradient!","page":"Evaluators","title":"ExaPF.gradient!","text":"gradient!(nlp::AbstractNLPEvaluator, g, u)\n\nEvaluate the gradient of the objective at point u. Store the result inplace in the vector g, which should have the same dimension as u.\n\n\n\n\n\n","category":"function"},{"location":"evaluators.html#ExaPF.constraint!","page":"Evaluators","title":"ExaPF.constraint!","text":"constraint!(nlp::AbstractNLPEvaluator, cons, u)\n\nEvaluate the constraints of the problem at point u. Store the result inplace, in the vector cons. The vector cons should have the same dimension as the result returned by n_constraints(nlp).\n\n\n\n\n\n","category":"function"},{"location":"evaluators.html#ExaPF.jacobian_structure!","page":"Evaluators","title":"ExaPF.jacobian_structure!","text":"jacobian_structure!(nlp::AbstractNLPEvaluator, rows, cols)\n\nReturn the sparsity pattern of the Jacobian matrix.\n\n\n\n\n\n","category":"function"},{"location":"evaluators.html#ExaPF.jacobian!","page":"Evaluators","title":"ExaPF.jacobian!","text":"jacobian!(nlp::ReducedSpaceEvaluator, jac, u)\n\nEvaluate the Jacobian of the problem at point u. Store the result inplace, in the vector jac.\n\n\n\n\n\n","category":"function"},{"location":"evaluators.html#ExaPF.hessian!","page":"Evaluators","title":"ExaPF.hessian!","text":"constraint!(nlp::AbstractNLPEvaluator, hess, u)\n\nEvaluate the Hessian of the problem at point u. Store the result inplace, in the vector hess.\n\n\n\n\n\n","category":"function"},{"location":"powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"CurrentModule = ExaPF\r\nDocTestSetup = quote\r\n    using ExaPF\r\n    const PS = ExaPF.PowerSystem\r\nend\r\nDocTestFilters = [r\"ExaPF\"]","category":"page"},{"location":"powersystem.html#PowerSystem","page":"PowerSystem","title":"PowerSystem","text":"","category":"section"},{"location":"powersystem.html#Description","page":"PowerSystem","title":"Description","text":"","category":"section"},{"location":"powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"PS.AbstractPowerSystem\r\nPS.PowerNetwork","category":"page"},{"location":"powersystem.html#ExaPF.PowerSystem.AbstractPowerSystem","page":"PowerSystem","title":"ExaPF.PowerSystem.AbstractPowerSystem","text":"AbstractPowerSystem\n\nFirst layer of the package. Store the topology of a given transmission network, including:\n\nthe power injection at each bus\nthe admittance matrix\nthe default voltage at each bus\n\nData are imported either from a matpower file, or a PSSE file.\n\n\n\n\n\n","category":"type"},{"location":"powersystem.html#ExaPF.PowerSystem.PowerNetwork","page":"PowerSystem","title":"ExaPF.PowerSystem.PowerNetwork","text":"PowerNetwork <: AbstractPowerSystem\n\nThis structure contains constant parameters that define the topology and physics of the power network.\n\nThe object PowerNetwork uses its own contiguous indexing for the buses. The indexing is independent from those specified in the Matpower or the PSSE input file. However, a correspondence between the two indexing (Input indexing to PowerNetwork indexing) is stored inside the attribute bus_to_indexes.\n\nNote\n\nThe object PowerNetwork is created in the main memory. Use a AbstractFormulation object to move data to the target device.\n\n\n\n\n\n","category":"type"},{"location":"powersystem.html#API-Reference","page":"PowerSystem","title":"API Reference","text":"","category":"section"},{"location":"powersystem.html#Network-elements","page":"PowerSystem","title":"Network elements","text":"","category":"section"},{"location":"powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"PS.AbstractNetworkElement","category":"page"},{"location":"powersystem.html#ExaPF.PowerSystem.AbstractNetworkElement","page":"PowerSystem","title":"ExaPF.PowerSystem.AbstractNetworkElement","text":"AbstractNetworkElement\n\nAbstraction for all physical elements being parts of a AbstractPowerSystem. Elements are divided in\n\ntransmission lines (Lines)\nbuses (Buses)\ngenerators (Generators)\n\n\n\n\n\n","category":"type"},{"location":"powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"List of elements:","category":"page"},{"location":"powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"PS.Buses\r\nPS.Lines\r\nPS.Generator","category":"page"},{"location":"powersystem.html#ExaPF.PowerSystem.Buses","page":"PowerSystem","title":"ExaPF.PowerSystem.Buses","text":"Buses <: AbstractNetworkElement\n\nBuses of a transmission network.\n\n\n\n\n\n","category":"type"},{"location":"powersystem.html#ExaPF.PowerSystem.Lines","page":"PowerSystem","title":"ExaPF.PowerSystem.Lines","text":"Lines <: AbstractNetworkElement\n\nLines of a transmission network.\n\n\n\n\n\n","category":"type"},{"location":"powersystem.html#ExaPF.PowerSystem.Generator","page":"PowerSystem","title":"ExaPF.PowerSystem.Generator","text":"Generator <: AbstractElement\n\nGenerator in a transmission network\n\n\n\n\n\n","category":"type"},{"location":"powersystem.html#Network-attributes","page":"PowerSystem","title":"Network attributes","text":"","category":"section"},{"location":"powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"PS.AbstractNetworkAttribute","category":"page"},{"location":"powersystem.html#ExaPF.PowerSystem.AbstractNetworkAttribute","page":"PowerSystem","title":"ExaPF.PowerSystem.AbstractNetworkAttribute","text":"AbstractNetworkAttribute\n\nAttribute of a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"Function for getting attributes from a network:","category":"page"},{"location":"powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"PS.get","category":"page"},{"location":"powersystem.html#ExaPF.PowerSystem.get","page":"PowerSystem","title":"ExaPF.PowerSystem.get","text":"get(pf::AbstractPowerSystem, attr::AbstractNetworkAttribute)\n\nReturn value of attribute attr in the AbstractPowerSystem object pf.\n\nget(pf::AbstractPowerSystem, attr::AbstractIndexing)\n\nReturn indexing corresponding to a subset of the buses.\n\nExamples\n\nnpq = get(pf, NumberOfPQBuses())\nnpv = get(pf, NumberOfPVBuses())\nindex_pv = get(pf, PVIndexes()())\nindex_gen = get(pf, GeneratorIndexes()())\n\n\n\n\n\n\n","category":"function"},{"location":"powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"List of attributes:","category":"page"},{"location":"powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"PS.NumberOfBuses\r\nPS.NumberOfLines\r\nPS.NumberOfGenerators\r\nPS.NumberOfPVBuses\r\nPS.NumberOfPQBuses\r\nPS.NumberOfSlackBuses\r\nPS.BaseMVA","category":"page"},{"location":"powersystem.html#ExaPF.PowerSystem.NumberOfBuses","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfBuses","text":"NumberOfBuses <: AbstractNetworkAttribute\n\nNumber of buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"powersystem.html#ExaPF.PowerSystem.NumberOfLines","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfLines","text":"NumberOfLines <: AbstractNetworkAttribute\n\nNumber of lines in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"powersystem.html#ExaPF.PowerSystem.NumberOfGenerators","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfGenerators","text":"NumberOfGenerators <: AbstractNetworkAttribute\n\nNumber of generators in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"powersystem.html#ExaPF.PowerSystem.NumberOfPVBuses","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfPVBuses","text":"NumberOfPVBuses <: AbstractNetworkAttribute\n\nNumber of PV buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"powersystem.html#ExaPF.PowerSystem.NumberOfPQBuses","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfPQBuses","text":"NumberOfPQBuses <: AbstractNetworkAttribute\n\nNumber of PQ buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"powersystem.html#ExaPF.PowerSystem.NumberOfSlackBuses","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfSlackBuses","text":"NumberOfSlackBuses <: AbstractNetworkAttribute\n\nNumber of slack buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"powersystem.html#ExaPF.PowerSystem.BaseMVA","page":"PowerSystem","title":"ExaPF.PowerSystem.BaseMVA","text":"BaseMVA <: AbstractNetworkAttribute\n\nBase MVA of the network.\n\n\n\n\n\n","category":"type"},{"location":"powersystem.html#Network-values","page":"PowerSystem","title":"Network values","text":"","category":"section"},{"location":"powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"PS.AbstractNetworkValues","category":"page"},{"location":"powersystem.html#ExaPF.PowerSystem.AbstractNetworkValues","page":"PowerSystem","title":"ExaPF.PowerSystem.AbstractNetworkValues","text":"AbstractNetworkValues\n\nNumerical values attached to the different attributes of the network.\n\n\n\n\n\n","category":"type"},{"location":"powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"List of values:","category":"page"},{"location":"powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"PS.VoltageMagnitude\r\nPS.VoltageAngle\r\nPS.ActivePower\r\nPS.ReactivePower\r\n","category":"page"},{"location":"powersystem.html#ExaPF.PowerSystem.VoltageMagnitude","page":"PowerSystem","title":"ExaPF.PowerSystem.VoltageMagnitude","text":"VoltageMagnitude <: AbstractNetworkValues\n\nMagnitude |v| of the voltage v = v exp(i θ).\n\n\n\n\n\n","category":"type"},{"location":"powersystem.html#ExaPF.PowerSystem.VoltageAngle","page":"PowerSystem","title":"ExaPF.PowerSystem.VoltageAngle","text":"VoltageAngle <: AbstractNetworkValues\n\nAngle θ of the voltage v = |v| exp(i θ).\n\n\n\n\n\n","category":"type"},{"location":"powersystem.html#ExaPF.PowerSystem.ActivePower","page":"PowerSystem","title":"ExaPF.PowerSystem.ActivePower","text":"ActivePower <: AbstractNetworkValues\n\nActive power P of the complex power S = P + iQ.\n\n\n\n\n\n","category":"type"},{"location":"powersystem.html#ExaPF.PowerSystem.ReactivePower","page":"PowerSystem","title":"ExaPF.PowerSystem.ReactivePower","text":"ReactivePower <: AbstractNetworkValues\n\nReactive power Q of the complex power S = P + iQ.\n\n\n\n\n\n","category":"type"},{"location":"powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"Function to get the range of a given value:","category":"page"},{"location":"powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"PS.bounds","category":"page"},{"location":"powersystem.html#ExaPF.PowerSystem.bounds","page":"PowerSystem","title":"ExaPF.PowerSystem.bounds","text":"bounds(pf::AbstractPowerSystem, attr::AbstractNetworkAttribute, val::AbstractNetworkValues)\n\nReturn lower and upper bounds corresponding to the admissible values of the AbstractNetworkAttribute attr.\n\nExamples\n\np_min, p_max = bounds(pf, Generator(), ActivePower())\nv_min, v_max = bounds(pf, Buses(), VoltageMagnitude())\n\n\n\n\n\n\n","category":"function"},{"location":"index.html#ExaPF","page":"Home","title":"ExaPF","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"ExaPF.jl is a package to solve powerflow problem on exascale architecture. ExaPF.jl aims to implement a reduced method for solving the optimal power flow problem (OPF) fully on GPUs. Reduced methods enforce the constraints, represented here by the power flow's (PF) system of nonlinear equations, separately at each iteration of the optimization in the reduced space. This paper describes the API of ExaPF.jl for solving the power flow's nonlinear equations (NLE) entirely on the GPU. This includes the computation of the derivatives using automatic differentiation, an iterative linear solver with a preconditioner, and a Newton-Raphson implementation. All of these steps allow us to run the main computational loop entirely on the GPU with no transfer from host to device.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This implementation will serve as the basis for the future optimal power flow (OPF) implementation as a nonlinear programming problem (NLP) in the reduced space.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"To make our implementation portable to CPU and GPU architectures we leverage two abstractions: arrays and kernels. Both of these abstractions are supported through the packages CUDA.jl and KernelAbstractions.jl Please take a look at the autodiff and linear solver  implementations to get a design overview of ExaPF.jl targeted for GPUs. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The user API is separated into three layers:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"First layer or physical layer: Power network topology in powersystem \nSecond layer: Interface between power network and NLE or NLP in formulations \nThird layer: Evaluators for NLE or NLP ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The third layer is for users working in optimization whereas the first layer is for electrical engineers. They meet in the second layer.","category":"page"},{"location":"index.html#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\"autodiff.md\", \"linearsolver.md\", \"powersystem.md\", \"formulations.md\", \"evaluators.md\"]\r\nDepth = 3","category":"page"},{"location":"autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"CurrentModule = ExaPF\r\nDocTestSetup = quote\r\n    using ExaPF\r\n    const AD = ExaPF.AD\r\nend\r\nDocTestFilters = [r\"ExaPF\"]","category":"page"},{"location":"autodiff.html#AutoDiff","page":"AutoDiff","title":"AutoDiff","text":"","category":"section"},{"location":"autodiff.html#Overview","page":"AutoDiff","title":"Overview","text":"","category":"section"},{"location":"autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"Given a set of equations F(x) = 0, the Newton-Raphson algorithm for solving nonlinear equations (see below) requires the Jacobian J = jacobian(x)  of F. At each iteration a new step dx is computed by solving a linear system. In our case J is sparse and indefinite.","category":"page"},{"location":"autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"  go = true\r\n  while(go)\r\n    dx .= jacobian(x)\\f(x)\r\n    x  .= x .- dx\r\n    go = norm(f(x)) < tol ? true : false\r\n  end","category":"page"},{"location":"autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"There are two modes of differentiation called forward/tangent or reverse/adjoint. The latter is known in machine learning as backpropagation. The forward mode generates Jacobian-vector product code tgt(x,d) = J(x) * d, while the adjoint mode generates code for the transposed Jacobian-vector product adj(x,y) = (J(x)'*y). We recommend @griewank2008evaluating for a more in-depth introduction to automatic differentiation. The computational complexity of both models favors the adjoint mode if the number of outputs of F is much smaller than the number of inputs size(x) >> size(F), like for example the loss functions in machine learning. However, in our case F is a multivariate vector function from mathbbR^n to mathbbR^n, where n is the number of buses.","category":"page"},{"location":"autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"(Image: Jacobian coloring \\label{fig:coloring})","category":"page"},{"location":"autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"To avoid a complexity of mathcalO(n) cdot cost(F) by letting the tangent mode run over all Cartesian basis vectors of mathbbR^n, we apply the technique of Jacobian coloring to compress the sparse Jacobian J. Running the tangent mode, it allows to compute columns of the Jacobian concurrently, by combining independent columns in one Jacobian-vector evaluation (see \\autoref{fig:coloring}). For sparsity detection we rely on the greedy algorithm implemented by SparseDiffTools.jl.","category":"page"},{"location":"autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"Given the sparsity pattern, the forward model is applied through the package ForwardDiff.jl. Given the number of Jaocbian colors c we can build our dual type t1s with c directions:","category":"page"},{"location":"autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"t1s{N} = ForwardDiff.Dual{Nothing,Float64, N} where N}","category":"page"},{"location":"autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"Note that a second-order type t2s can be created naturally by applying the same logic to t1s:","category":"page"},{"location":"autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"t2s{M,N} =  ForwardDiff.Dual{Nothing,t1s{N}, M} where M, N}","category":"page"},{"location":"autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"Finally, this dual type can be ported to both vector types Vector and CuVector:","category":"page"},{"location":"autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"T = Vector{Float64}\r\nT = Vector{t1s{N}}}\r\nT = CuVector{t1s{N}}}","category":"page"},{"location":"autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"Setting T to either of the three types allows us to instantiate code that has been written using the broadcast operator . ","category":"page"},{"location":"autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"x .= a .* b","category":"page"},{"location":"autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"or accessed in kernels written for KernelAbstractions.jl like for example the power flow equations (here in polar form):","category":"page"},{"location":"autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"@kernel function residual_kernel!(F, v_m, v_a,\r\n                                  ybus_re_nzval, ybus_re_colptr, ybus_re_rowval,\r\n                                  ybus_im_nzval, ybus_im_colptr, ybus_im_rowval,\r\n                                  pinj, qinj, pv, pq, nbus)\r\n\r\n    npv = size(pv, 1)\r\n    npq = size(pq, 1)\r\n\r\n    i = @index(Global, Linear)\r\n    # REAL PV: 1:npv\r\n    # REAL PQ: (npv+1:npv+npq)\r\n    # IMAG PQ: (npv+npq+1:npv+2npq)\r\n    fr = (i <= npv) ? pv[i] : pq[i - npv]\r\n    F[i] -= pinj[fr]\r\n    if i > npv\r\n        F[i + npq] -= qinj[fr]\r\n    end\r\n    @inbounds for c in ybus_re_colptr[fr]:ybus_re_colptr[fr+1]-1\r\n        to = ybus_re_rowval[c]\r\n        aij = v_a[fr] - v_a[to]\r\n        coef_cos = v_m[fr]*v_m[to]*ybus_re_nzval[c]\r\n        coef_sin = v_m[fr]*v_m[to]*ybus_im_nzval[c]\r\n        cos_val = cos(aij)\r\n        sin_val = sin(aij)\r\n        F[i] += coef_cos * cos_val + coef_sin * sin_val\r\n        if i > npv\r\n            F[npq + i] += coef_cos * sin_val - coef_sin * cos_val\r\n        end\r\n    end\r\nend","category":"page"},{"location":"autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"These two abstractions are a powerful tool that allow us to implement the forward mode in vectorized form where the number of directions or tangent components of a tangent variable are the number of Jacobian colors. We illustrate this in \\autoref{fig:simd} with a point-wise vector product x .* y","category":"page"},{"location":"autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"(Image: SIMD AD for point-wise vector product \\label{fig:simd})","category":"page"},{"location":"autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"This natural way of computing the compressed Jacobian yields a very high performing code that is portable to any vector architecture, given that a similar package like CUDA.jl exists. We note that similar packages for the Intel Compute Engine and AMD ROCm are in development called oneAPI.jl and AMDGPU.jl, respectively. We expect our package to be portable to AMD and Intel GPUs in the future.","category":"page"},{"location":"autodiff.html#Description","page":"AutoDiff","title":"Description","text":"","category":"section"},{"location":"autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"AD.AbstractADFramework","category":"page"},{"location":"autodiff.html#ExaPF.AD.AbstractADFramework","page":"AutoDiff","title":"ExaPF.AD.AbstractADFramework","text":"AbstractADFramework\n\nAutomatic differentiation for the compressed Jacobians of the constraints g(x,u) with respect to the state x and the control u (here called design). \n\nTODO: Use dispatch to unify the code of the state and control Jacobian. This is currently not done because the abstraction of the indexing is not yet resolved.\n\n\n\n\n\n","category":"type"},{"location":"autodiff.html#API-Reference","page":"AutoDiff","title":"API Reference","text":"","category":"section"},{"location":"autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"AD.StateJacobianAD\r\nAD.DesignJacobianAD\r\nAD.myseed_kernel_cpu\r\nAD.myseed_kernel_gpu\r\nAD.seeding\r\nAD.getpartials_cpu\r\nAD.getpartials_gpu\r\nAD.getpartials\r\nAD._uncompress\r\nAD.uncompress!\r\nAD.residualJacobianAD!","category":"page"},{"location":"autodiff.html#ExaPF.AD.StateJacobianAD","page":"AutoDiff","title":"ExaPF.AD.StateJacobianAD","text":"StateJacobianAD\n\nCreates an object for the state Jacobian\n\nJ::SMT: Sparse uncompressed Jacobian to be used by linear solver. This is either of type SparseMatrixCSC or CuSparseMatrixCSR.\ncompressedJ::MT: Dense compressed Jacobian used for updating values through AD either of type Matrix or CuMatrix.\ncoloring::VI: Row coloring of the Jacobian.\nt1sseeds::VP: The seeding vector for AD built based on the coloring.\nt1sF::VD: Output array of active (AD) type.\nx::VT: Input array of passive type. This includes both state and control.\nt1sx::VD: Input array of active type. \nmap::VI: State and control mapping to array x\nvarx::SubT: View of map on x\nt1svarx::SubD: Active (AD) view of map on x\n\n\n\n\n\n","category":"type"},{"location":"autodiff.html#ExaPF.AD.DesignJacobianAD","page":"AutoDiff","title":"ExaPF.AD.DesignJacobianAD","text":"DesignJacobianAD\n\nCreates an object for the control Jacobian.\n\nJ::SMT: Sparse uncompressed Jacobian to be used by linear solver. This is either of type SparseMatrixCSC or CuSparseMatrixCSR.\ncompressedJ::MT: Dense compressed Jacobian used for updating values through AD either of type Matrix or CuMatrix.\ncoloring::VI: Row coloring of the Jacobian.\nt1sseeds::VP: The seeding vector for AD built based on the coloring.\nt1sF::VD: Output array of active (AD) type.\nx::VT: Input array of passive type. This includes both state and control.\nt1sx::VD: Input array of active type. \nmap::VI: State and control mapping to array x\nvarx::SubT: View of map on x\nt1svarx::SubD: Active (AD) view of map on x\n\n\n\n\n\n","category":"type"},{"location":"autodiff.html#ExaPF.AD.myseed_kernel_cpu","page":"AutoDiff","title":"ExaPF.AD.myseed_kernel_cpu","text":"myseed_kernel_cpu\n\nSeeding on the CPU, not parallelized. \n\n\n\n\n\n","category":"function"},{"location":"autodiff.html#ExaPF.AD.myseed_kernel_gpu","page":"AutoDiff","title":"ExaPF.AD.myseed_kernel_gpu","text":"myseed_kernel_cpu\n\nSeeding on GPU parallelized over the ncolor number of duals \n\n\n\n\n\n","category":"function"},{"location":"autodiff.html#ExaPF.AD.seeding","page":"AutoDiff","title":"ExaPF.AD.seeding","text":"seeding(t1sseeds::CuVector{ForwardDiff.Partials{N,V}}, varx, t1svarx, nbus) where {N, V}\n\nCalling the GPU seeding kernel\n\n\n\n\n\nseeding(t1sseeds::Vector{ForwardDiff.Partials{N,V}}, varx, t1svarx, nbus) where {N, V}\n\nCalling the CPU seeding kernel\n\n\n\n\n\n","category":"function"},{"location":"autodiff.html#ExaPF.AD.getpartials_cpu","page":"AutoDiff","title":"ExaPF.AD.getpartials_cpu","text":"getpartials_cpu(compressedJ, t1sF)\n\nExtract the partials from the AD dual type on the CPU and put it in the compressed Jacobian\n\n\n\n\n\n","category":"function"},{"location":"autodiff.html#ExaPF.AD.getpartials_gpu","page":"AutoDiff","title":"ExaPF.AD.getpartials_gpu","text":"getpartials_gpu(compressedJ, t1sF)\n\nExtract the partials from the AD dual type on the GPU and put it in the compressed Jacobian\n\n\n\n\n\n","category":"function"},{"location":"autodiff.html#ExaPF.AD.getpartials","page":"AutoDiff","title":"ExaPF.AD.getpartials","text":"getpartials(compressedJ::CuArray{T, 2}, t1sF, nbus) where T\n\nCalling the GPU partial extraction kernel\n\n\n\n\n\ngetpartials(compressedJ::Array{T, 2}, t1sF, nbus) where T\n\nCalling the GPU partial extraction kernel\n\n\n\n\n\n","category":"function"},{"location":"autodiff.html#ExaPF.AD._uncompress","page":"AutoDiff","title":"ExaPF.AD._uncompress","text":"_uncompress(J_nzVal, J_rowPtr, J_colVal, compressedJ, coloring, nmap)\n\nUncompress the compressed Jacobian matrix from compressedJ to sparse CSR on the GPU. Only bitarguments are allowed for the kernel. (for GPU only) TODO: should convert to @kernel\n\n\n\n\n\n","category":"function"},{"location":"autodiff.html#ExaPF.AD.uncompress!","page":"AutoDiff","title":"ExaPF.AD.uncompress!","text":"uncompress!(J::SparseArrays.SparseMatrixCSC, compressedJ, coloring)\n\nUncompress the compressed Jacobian matrix from compressedJ to sparse CSC on the CPU. \n\n\n\n\n\nuncompress!(J::CUDA.CUSPARSE.CuSparseMatrixCSR, compressedJ, coloring)\n\nUncompress the compressed Jacobian matrix from compressedJ to sparse CSC on the GPU by calling the kernel _uncompress.\n\n\n\n\n\n","category":"function"},{"location":"autodiff.html#ExaPF.AD.residualJacobianAD!","page":"AutoDiff","title":"ExaPF.AD.residualJacobianAD!","text":"residualJacobianAD!(arrays::StateJacobianAD, \n                    residualFunction_polar!, \n                    v_m, v_a, ybus_re, ybus_im, pinj, qinj, pv, pq, ref, nbus, \n                    timer = nothing)\n\nUpdate the sparse Jacobian entries using AD. No allocations are taking place in this function.\n\narrays::StateJacobianAD: Factory created Jacobian object to update\nresidualFunction_polar: Primal function\nv_m, v_a, ybus_re, ybus_im, pinj, qinj, pv, pq, ref, nbus: Inputs both active and passive parameters. Active inputs are mapped to x via the preallocated views.\n\n\n\n\n\nresidualJacobianAD!(arrays::DesignJacobianAD, \n                    residualFunction_polar!, \n                    v_m, v_a, ybus_re, ybus_im, pinj, qinj, pv, pq, ref, nbus, \n                    timer = nothing)\n\nUpdate the sparse Jacobian entries using AD. No allocations are taking place in this function.\n\narrays::DesignJacobianAD: Factory created Jacobian object to update\nresidualFunction_polar: Primal function\nv_m, v_a, ybus_re, ybus_im, pinj, qinj, pv, pq, ref, nbus: Inputs both active and passive parameters. Active inputs are mapped to x via the preallocated views.\n\n\n\n\n\n","category":"function"}]
}
