var documenterSearchIndex = {"docs":
[{"location":"lib/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"CurrentModule = ExaPF.LinearSolvers","category":"page"},{"location":"lib/linearsolver.html#Linear-solvers","page":"Linear Solver","title":"Linear solvers","text":"","category":"section"},{"location":"lib/linearsolver.html#Description","page":"Linear Solver","title":"Description","text":"","category":"section"},{"location":"lib/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"ExaPF allows to solve linear systems with either direct and indirect linear algebra, both on CPU and on GPU. To solve a linear system Ax = b, ExaPF uses the function ldiv!.","category":"page"},{"location":"lib/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"ldiv!","category":"page"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.ldiv!","page":"Linear Solver","title":"ExaPF.LinearSolvers.ldiv!","text":"ldiv!(solver, x, A, y)\nldiv!(solver, x, y)\n\nsolver::AbstractLinearSolver: linear solver to solve the system\nx::AbstractVector: Solution\nA::AbstractMatrix: Input matrix\ny::AbstractVector: RHS\n\nSolve the linear system A x = y using the algorithm specified in solver. If A is not specified, the function will used directly the factorization stored inplace.\n\n\n\n\n\n","category":"function"},{"location":"lib/linearsolver.html#Direct-solvers","page":"Linear Solver","title":"Direct solvers","text":"","category":"section"},{"location":"lib/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"ExaPF wraps UMFPACK (shipped with Julia) on the CPU, and CUSPARSE on CUDA device.","category":"page"},{"location":"lib/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"DirectSolver","category":"page"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.DirectSolver","page":"Linear Solver","title":"ExaPF.LinearSolvers.DirectSolver","text":"DirectSolver <: AbstractLinearSolver\n\nSolve linear system A x = y with direct linear algebra.\n\nOn the CPU, DirectSolver uses UMFPACK to solve the linear system\nOn CUDA GPU, DirectSolver redirects the resolution to the method CUSOLVER.csrlsvqr\n\n\n\n\n\n","category":"type"},{"location":"lib/linearsolver.html#Iterative-solvers","page":"Linear Solver","title":"Iterative solvers","text":"","category":"section"},{"location":"lib/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"KrylovBICGSTAB\nBICGSTAB\nEigenBICGSTAB","category":"page"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.KrylovBICGSTAB","page":"Linear Solver","title":"ExaPF.LinearSolvers.KrylovBICGSTAB","text":"KrylovBICGSTAB <: AbstractIterativeLinearSolver\nKrylovBICGSTAB(precond; verbose=0, rtol=1e-10, atol=1e-10)\n\nWrap Krylov.jl's BICGSTAB algorithm to solve iteratively the linear system A x = y.\n\n\n\n\n\n","category":"type"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.BICGSTAB","page":"Linear Solver","title":"ExaPF.LinearSolvers.BICGSTAB","text":"BICGSTAB <: AbstractIterativeLinearSolver\nBICGSTAB(precond; maxiter=2_000, tol=1e-8, verbose=false)\n\nCustom BICGSTAB implementation to solve iteratively the linear system A  x = y.\n\n\n\n\n\n","category":"type"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.EigenBICGSTAB","page":"Linear Solver","title":"ExaPF.LinearSolvers.EigenBICGSTAB","text":"EigenBICGSTAB <: AbstractIterativeLinearSolver\nEigenBICGSTAB(precond; maxiter=2_000, tol=1e-8, verbose=false)\n\nJulia's port of Eigen's BICGSTAB to solve iteratively the linear system A x = y.\n\n\n\n\n\n","category":"type"},{"location":"lib/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"ExaPF.jl is shipped with a custom BICGSTAB implementation. However, we highly recommend to use KrylovBICGSTAB instead, which has proved to be more robust.","category":"page"},{"location":"lib/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"bicgstab\n","category":"page"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.bicgstab","page":"Linear Solver","title":"ExaPF.LinearSolvers.bicgstab","text":"bicgstab(A, b, P, xi;\n         tol=1e-8,\n         maxiter=size(A, 1),\n         verbose=false,\n         maxtol=1e20)\n\nBiCGSTAB implementation according to\n\nVan der Vorst, Henk A. \"Bi-CGSTAB: A fast and smoothly converging variant of Bi-CG for the solution of nonsymmetric linear systems.\" SIAM Journal on scientific and Statistical Computing 13, no. 2 (1992): 631-644.\n\n\n\n\n\n","category":"function"},{"location":"lib/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"Available linear solvers could be queried with","category":"page"},{"location":"lib/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"list_solvers\n","category":"page"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.list_solvers","page":"Linear Solver","title":"ExaPF.LinearSolvers.list_solvers","text":"list_solvers(::KernelAbstractions.Device)\n\nList linear solvers available on current device. Currently, only CPU() and CUDADevice() are supported.\n\n\n\n\n\n","category":"function"},{"location":"lib/linearsolver.html#Preconditioning","page":"Linear Solver","title":"Preconditioning","text":"","category":"section"},{"location":"lib/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"To solve linear systems with iterative methods, ExaPF provides an implementation of a block-Jacobi preconditioner, portable on GPU.","category":"page"},{"location":"lib/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"AbstractPreconditioner","category":"page"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.AbstractPreconditioner","page":"Linear Solver","title":"ExaPF.LinearSolvers.AbstractPreconditioner","text":"AbstractPreconditioner\n\nPreconditioners for the iterative solvers mostly focused on GPUs\n\n\n\n\n\n","category":"type"},{"location":"lib/linearsolver.html#Block-Jacobi-preconditioner","page":"Linear Solver","title":"Block-Jacobi preconditioner","text":"","category":"section"},{"location":"lib/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"BlockJacobiPreconditioner\nupdate\nbuild_adjmatrix\nfillblock_gpu!\nfillP_gpu!","category":"page"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.BlockJacobiPreconditioner","page":"Linear Solver","title":"ExaPF.LinearSolvers.BlockJacobiPreconditioner","text":"BlockJacobiPreconditioner\n\nCreates an object for the block-Jacobi preconditioner\n\nnblocks::Int64: Number of partitions or blocks.\nblocksize::Int64: Size of each block.\nnJs::Int64: Size of the blocks. For the GPUs these all have to be of equal size.\npartitions::Vector{Vector{Int64}}:npart` partitions stored as lists\ncupartitions: partitions transfered to the GPU\nlpartitions::Vector{Int64}`: Length of each partitions.\nculpartitions::Vector{Int64}`: Length of each partitions, on the GPU.\nblocks: Dense blocks of the block-Jacobi\ncublocks: Js transfered to the GPU\nmap: The partitions as a mapping to construct views\ncumap: cumap transferred to the GPU`\npart: Partitioning as output by Metis\ncupart: part transferred to the GPU\nP: The sparse precondition matrix whose values are updated at each iteration\n\n\n\n\n\n","category":"type"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.update","page":"Linear Solver","title":"ExaPF.LinearSolvers.update","text":"function update(J::CuSparseMatrixCSR, p)\n\nUpdate the preconditioner p from the sparse Jacobian J in CSR format for the GPU\n\nThe dense blocks cuJs are filled from the sparse Jacobian J\nTo a batch inversion of the dense blocks using CUBLAS\nExtract the preconditioner matrix p.P from the dense blocks cuJs\n\n\n\n\n\nfunction update(J::SparseMatrixCSC, p)\n\nUpdate the preconditioner p from the sparse Jacobian J in CSC format for the CPU\n\nNote that this implements the same algorithm as for the GPU and becomes very slow on CPU with growing number of blocks.\n\n\n\n\n\n","category":"function"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.build_adjmatrix","page":"Linear Solver","title":"ExaPF.LinearSolvers.build_adjmatrix","text":"build_adjmatrix\n\nBuild the adjacency matrix of a matrix A corresponding to the undirected graph\n\n\n\n\n\n","category":"function"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.fillblock_gpu!","page":"Linear Solver","title":"ExaPF.LinearSolvers.fillblock_gpu!","text":"fillblock_gpu\n\nFill the dense blocks of the preconditioner from the sparse CSR matrix arrays\n\n\n\n\n\n","category":"function"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.fillP_gpu!","page":"Linear Solver","title":"ExaPF.LinearSolvers.fillP_gpu!","text":"fillP_gpu\n\nUpdate the values of the preconditioner matrix from the dense Jacobi blocks\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"CurrentModule = ExaPF","category":"page"},{"location":"lib/formulations.html#Formulations","page":"Formulations","title":"Formulations","text":"","category":"section"},{"location":"lib/formulations.html#Description","page":"Formulations","title":"Description","text":"","category":"section"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"AbstractFormulation\nPolarForm\n","category":"page"},{"location":"lib/formulations.html#ExaPF.AbstractFormulation","page":"Formulations","title":"ExaPF.AbstractFormulation","text":"AbstractFormulation\n\nSecond layer of the package, implementing the interface between the first layer (the topology of the network) and the third layer (implementing the callbacks for the optimization solver).\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#ExaPF.PolarForm","page":"Formulations","title":"ExaPF.PolarForm","text":"PolarForm{T, IT, VT, MT}\n\nTakes as input a PS.PowerNetwork network and implement the polar formulation model associated to this network. The structure PolarForm stores the topology of the network, as well as the complete indexing used in the polar formulation.\n\nA PolarForm structure can be instantiated both on the host CPU() or directly on the device CUDADevice().\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#Powerflow-solver","page":"Formulations","title":"Powerflow solver","text":"","category":"section"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"powerflow\nNewtonRaphson\n","category":"page"},{"location":"lib/formulations.html#ExaPF.powerflow","page":"Formulations","title":"ExaPF.powerflow","text":"powerflow(form::AbstractFormulation,\n          algo::AbstractNonLinearSolver;\n          kwargs...)\n\npowerflow(form::AbstractFormulation,\n          jacobian::AutoDiff.Jacobian,\n          buffer::AbstractNetworkBuffer,\n          algo::AbstractNonLinearSolver;\n          kwargs...) where VT <: AbstractVector\n\nSolve the power flow equations g(x u) = 0 w.r.t. the state x, using the algorithm specified in algo (NewtonRaphson by default). The initial state x is specified inside buffer. The object buffer is modified inplace in the function.\n\nThe algorithm stops when a tolerance tol or a maximum number of iterations maxiter is reached (these parameters being specified in the object algo).\n\nNotes\n\nIf only the arguments form and algo are specified to the function, then the Jacobian jacobian and the cache buffer are inferred from the object form.\n\nArguments\n\nform::AbstractFormulation: formulation of the power flow equation\njacobian::AutoDiff.Jacobian: Jacobian\nbuffer::AbstractNetworkBuffer: buffer storing current state x and control u\nalgo::AbstractNonLinearSolver: non-linear solver. Currently only NewtonRaphson is being implemented.\n\nOptional arguments\n\nlinear_solver::AbstractLinearSolver (default DirectSolver()): solver to solve the linear systems J x = y arising at each iteration of the Newton-Raphson algorithm.\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#ExaPF.NewtonRaphson","page":"Formulations","title":"ExaPF.NewtonRaphson","text":"NewtonRaphson <: AbstractNonLinearSolver\n\nNewton-Raphson algorithm. Used to solve the non-linear equation g(x u) = 0, at a fixed control u.\n\nAttributes\n\nmaxiter::Int (default 20): maximum number of iterations\ntol::Float64 (default 1e-8): tolerance of the algorithm\nverbose::Int (default NONE): verbosity level\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#Constraints","page":"Formulations","title":"Constraints","text":"","category":"section"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"Current supported constraints are:","category":"page"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"voltage_magnitude_constraints\nactive_power_constraints\nreactive_power_constraints\nflow_constraints\npower_balance\n","category":"page"},{"location":"lib/formulations.html#ExaPF.voltage_magnitude_constraints","page":"Formulations","title":"ExaPF.voltage_magnitude_constraints","text":"voltage_magnitude_constraints(form::AbstractFormulation, cons::AbstractVector, buffer::AbstractNetworkBuffer)\n\nBounds the voltage magnitudes at PQ nodes:\n\nv_pq^  v_pq  v_pq^ \n\nThe result is stored inplace, inside cons.\n\nNote\n\nThe constraints on the voltage magnitudes at PV nodes v_pv are taken into account when bounding the control u.\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#ExaPF.active_power_constraints","page":"Formulations","title":"ExaPF.active_power_constraints","text":"active_power_constraints(form::AbstractFormulation, cons::AbstractVector, buffer::AbstractNetworkBuffer)\n\nEvaluate the constraints on the active power production at the generators that are not already taken into account in the bound constraints.\n\np_g^  p_g  p_g^  \n\nThe result is stored inplace, inside the vector cons.\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#ExaPF.reactive_power_constraints","page":"Formulations","title":"ExaPF.reactive_power_constraints","text":"reactive_power_constraints(form::AbstractFormulation, cons::AbstractVector, buffer::AbstractNetworkBuffer)\n\nEvaluate the constraints on the reactive power production at the generators:\n\nq_g^  q_g  q_g^  \n\nThe result is stored inplace, inside the vector cons.\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#ExaPF.flow_constraints","page":"Formulations","title":"ExaPF.flow_constraints","text":"flow_constraints(form::AbstractFormulation, cons::AbstractVector, buffer::AbstractNetworkBuffer)\n\nEvaluate the thermal limit constraints porting on the lines of the network. The result is stored inplace, inside the vector cons.\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#ExaPF.power_balance","page":"Formulations","title":"ExaPF.power_balance","text":"power_balance(form::AbstractFormulation, cons::AbstractVector, buffer::AbstractNetworkBuffer)\n\nEvaluate the power balance in the network:\n\ng(x u) = 0 \n\ncorresponding to the balance equations\n\nbeginaligned\n    p_i = v_i sum_j^n v_j (g_ijcos(theta_i - theta_j) + b_ijsin(theta_i - theta_j))  \n     i  PV PQ \n    q_i = v_i sum_j^n v_j (g_ijsin(theta_i - theta_j) - b_ijcos(theta_i - theta_j))  \n     i  PQ \nendaligned\n\nThe result is stored inplace, inside the vector cons.\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"These functions allow to query constraints' attributes:","category":"page"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"is_constraint\nsize_constraint\nbounds\n","category":"page"},{"location":"lib/formulations.html#ExaPF.is_constraint","page":"Formulations","title":"ExaPF.is_constraint","text":"size_constraint(cons_func::Function)::Bool\n\nReturn whether the function cons_func is a supported constraint in the powerflow model.\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#ExaPF.size_constraint","page":"Formulations","title":"ExaPF.size_constraint","text":"size_constraint(form::AbstractFormulation, cons_func::Function)::Int\n\nGet number of constraints specified by the function cons_func in the formulation form.\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#ExaPF.bounds","page":"Formulations","title":"ExaPF.bounds","text":"bounds(form::AbstractFormulation, var::AbstractVariable)\n\nReturn the bounds attached to the variable var.\n\nbounds(form::AbstractFormulation, func::Function)\n\nReturn a tuple of vectors (lb, ub) specifying the admissible range of the constraints specified by the function cons_func.\n\nExamples\n\nu_min, u_max = bounds(form, Control())\nh_min, h_max = bounds(form, reactive_power_constraints)\n\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"ExaPF implements special functions to compute the derivatives of each constraints:","category":"page"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"adjoint!\njacobian_transpose_product!\nmatpower_jacobian\nmatpower_hessian\njacobian_sparsity","category":"page"},{"location":"lib/formulations.html#ExaPF.adjoint!","page":"Formulations","title":"ExaPF.adjoint!","text":"adjoint!(form::AbstractFormulation, pbm::AutoDiff.TapeMemory, adj_h, h, buffer)\n\nReturn the adjoint w.r.t. the variables of the network (voltage magnitudes and angles, power injection) for the constraint stored inside the AutoDiff.TapeMemory object pbm. The results are stored directly inside the stack stored inside pbm.\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#ExaPF.jacobian_transpose_product!","page":"Formulations","title":"ExaPF.jacobian_transpose_product!","text":"jacobian_transpose_product!(form::AbstractFormulation, pbm::AutoDiff.TapeMemory, buffer, v)\n\nReturn the two transpose-Jacobian vector product (Jᵤ^ v Jₓ^ v)  w.r.t. the control u and the state x. Store the two resulting vectors directly inside the AutoDiff.TapeMemory pbm.\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#ExaPF.matpower_jacobian","page":"Formulations","title":"ExaPF.matpower_jacobian","text":"matpower_jacobian(form::AbstractFormulation, X::Union{State,Control}, cons_func::Function, V::Vector{Complex})\nmatpower_jacobian(form::AbstractFormulation, X::Union{State,Control}, cons_func::Function, buffer::AbstractNetworkBuffer)\n\nFor the constraint cons_func, return the expression of the Jacobian J w.r.t. the state or the control (depending on the argument X), as given by MATPOWER.\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#ExaPF.matpower_hessian","page":"Formulations","title":"ExaPF.matpower_hessian","text":"matpower_hessian(form::AbstractFormulation, cons_func::Function, buffer::AbstractNetworkBuffer, λ::AbstractVector)\n\nFor constraint cons_func, return the three matrices (λ^ H_xx λ^ H_xuλ^ H_uu) storing the product of the Hessian tensor H with the vector lambda. The expressions of the Hessian matrices are given by MATPOWER.\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#ExaPF.jacobian_sparsity","page":"Formulations","title":"ExaPF.jacobian_sparsity","text":"jacobian_sparsity(form::AbstractFormulation, cons_func::Function, X::Union{State,Control})\n\nFor the constraint cons_func, return the sparsity pattern of the Jacobian J w.r.t. the state or the control (depending on the argument X).\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#API-Reference","page":"Formulations","title":"API Reference","text":"","category":"section"},{"location":"lib/formulations.html#Variables","page":"Formulations","title":"Variables","text":"","category":"section"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"AbstractVariable\nState\nControl\nPhysicalState\n","category":"page"},{"location":"lib/formulations.html#ExaPF.AbstractVariable","page":"Formulations","title":"ExaPF.AbstractVariable","text":"AbstractVariable\n\nVariables corresponding to a particular formulation.\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#ExaPF.State","page":"Formulations","title":"ExaPF.State","text":"State <: AbstractVariable\n\nAll variables x depending on the variables Control u through a non-linear equation g(x u) = 0.\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#ExaPF.Control","page":"Formulations","title":"ExaPF.Control","text":"Control <: AbstractVariable\n\nIndependent variables u used in the reduced-space formulation.\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#ExaPF.PhysicalState","page":"Formulations","title":"ExaPF.PhysicalState","text":"PhysicalState <: AbstractVariable\n\nAll physical variables describing the current physical state of the underlying network.\n\nPhysicalState variables are encoded in a AbstractNetworkBuffer, storing all the physical values needed to describe the current state of the network.\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"Get default values attached to a given variable:","category":"page"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"initial\n","category":"page"},{"location":"lib/formulations.html#ExaPF.initial","page":"Formulations","title":"ExaPF.initial","text":"initial(form::AbstractFormulation, var::AbstractVariable)\n\nReturn an initial position for the variable var.\n\nExamples\n\nu₀ = initial(form, Control())\nx₀ = initial(form, State())\n\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#Attributes","page":"Formulations","title":"Attributes","text":"","category":"section"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"AbstractFormAttribute\nNumberOfState\nNumberOfControl\n","category":"page"},{"location":"lib/formulations.html#ExaPF.AbstractFormAttribute","page":"Formulations","title":"ExaPF.AbstractFormAttribute","text":"AbstractFormAttribute\n\nAttributes attached to an AbstractFormulation.\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#ExaPF.NumberOfState","page":"Formulations","title":"ExaPF.NumberOfState","text":"Number of states attached to a particular formulation.\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#ExaPF.NumberOfControl","page":"Formulations","title":"ExaPF.NumberOfControl","text":"Number of controls attached to a particular formulation.\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"ExaPF extends Base.get to query the different attributes of a model:","category":"page"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"get\n","category":"page"},{"location":"lib/formulations.html#Base.get","page":"Formulations","title":"Base.get","text":"get(form::AbstractFormulation, attr::AbstractFormAttribute)\n\nReturn value of attribute attr attached to the particular formulation form.\n\nExamples\n\nget(form, NumberOfState())\nget(form, NumberOfControl())\n\n\n\n\n\n\nget(pf::AbstractPowerSystem, attr::AbstractNetworkAttribute)\n\nReturn value of attribute attr in the AbstractPowerSystem object pf.\n\nget(pf::AbstractPowerSystem, attr::AbstractIndexing)\n\nReturn indexing corresponding to a subset of the buses.\n\nExamples\n\nnpq = get(pf, NumberOfPQBuses())\nnpv = get(pf, NumberOfPVBuses())\nindex_pv = get(pf, PVIndexes()())\nindex_gen = get(pf, GeneratorIndexes()())\n\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"The associated setter is implemented with setvalues!:","category":"page"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"setvalues!","category":"page"},{"location":"lib/formulations.html#ExaPF.setvalues!","page":"Formulations","title":"ExaPF.setvalues!","text":"setvalues!(form::AbstractFormulation, attr::PS.AbstractNetworkAttribute, values)\n\nUpdate inplace the attribute's values specified by attr.\n\nExamples\n\nsetvalues!(form, ActiveLoad(), new_ploads)\nsetvalues!(form, ReactiveLoad(), new_qloads)\n\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#Costs","page":"Formulations","title":"Costs","text":"","category":"section"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"cost_production","category":"page"},{"location":"lib/formulations.html#ExaPF.cost_production","page":"Formulations","title":"ExaPF.cost_production","text":"cost_production(form::AbstractFormulation, buffer::AbstractNetworkBuffer)::Float64\n\nGet operational cost.\n\n\n\n\n\n","category":"function"},{"location":"lib/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"CurrentModule = ExaPF.AutoDiff","category":"page"},{"location":"lib/autodiff.html#AutoDiff","page":"AutoDiff","title":"AutoDiff","text":"","category":"section"},{"location":"lib/autodiff.html#Adjoint","page":"AutoDiff","title":"Adjoint","text":"","category":"section"},{"location":"lib/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"TapeMemory","category":"page"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.TapeMemory","page":"AutoDiff","title":"ExaPF.AutoDiff.TapeMemory","text":"TapeMemory{F, S, I}\n\nThis object is used as a buffer to compute the adjoint of a given function h(x). It stores internally all intermediate values necessary to compute the adjoint, and cache the stack used in the backward pass.\n\nNote\n\nThis structure is largely inspired from ChainRulesCore.jl.\n\n\n\n\n\n","category":"type"},{"location":"lib/autodiff.html#Jacobian","page":"AutoDiff","title":"Jacobian","text":"","category":"section"},{"location":"lib/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"AbstractJacobian\nConstantJacobian\nJacobian\njacobian!","category":"page"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.AbstractJacobian","page":"AutoDiff","title":"ExaPF.AutoDiff.AbstractJacobian","text":"AbstractJacobian\n\nAutomatic differentiation for the compressed Jacobian of any nonlinear constraint h(x).\n\n\n\n\n\n","category":"type"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.ConstantJacobian","page":"AutoDiff","title":"ExaPF.AutoDiff.ConstantJacobian","text":"AutoDiff.ConstantJacobian <: AbstractJacobian\n\nCreates a constant Jacobian object for a linear function h(x). Using a ConstantJacobian object allows to avoid computing the full Jacobian with AutoDiff when it is not necessary.\n\n\n\n\n\n","category":"type"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.Jacobian","page":"AutoDiff","title":"ExaPF.AutoDiff.Jacobian","text":"AutoDiff.Jacobian <: AbstractJacobian\n\nCreates an object to compute the Jacobian with ForwardDiff.\n\nAttributes\n\nfunc::Func: base function to differentiate\nvar::Union{State,Control}: specify whether we are differentiating w.r.t. the state or the control.\nJ::SMT: Sparse uncompressed Jacobian to be used by linear solver. This is either of type SparseMatrixCSC or CuSparseMatrixCSR.\ncompressedJ::MT: Dense compressed Jacobian used for updating values through AD either of type Matrix or CuMatrix.\ncoloring::VI: Row coloring of the Jacobian.\nt1sseeds::VP: The seeding vector for AD built based on the coloring.\nt1sF::VD: Output array of active (AD) type.\nx::VT: Input array of passive type. This includes both state and control.\nt1sx::VD: Input array of active type.\nmap::VI: State and control mapping to array x\nvarx::SubT: View of map on x\nt1svarx::SubD: Active (AD) view of map on x\n\n\n\n\n\n","category":"type"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.jacobian!","page":"AutoDiff","title":"ExaPF.AutoDiff.jacobian!","text":"jacobian!(form::AbstractFormulation, jac::AutoDiff.AbstractJacobian, x)\n\nUpdate inplace the Jacobian J stored inside jac at a new point x.\n\n\n\n\n\n","category":"function"},{"location":"lib/autodiff.html#API-reference-for-the-Jacobian","page":"AutoDiff","title":"API reference for the Jacobian","text":"","category":"section"},{"location":"lib/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"seed!\ngetpartials_kernel!\nuncompress_kernel!","category":"page"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.seed!","page":"AutoDiff","title":"ExaPF.AutoDiff.seed!","text":"seed!\n\nCalling the seeding kernel. Seeding is parallelized over the ncolor number of duals.\n\n\n\n\n\n","category":"function"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.getpartials_kernel!","page":"AutoDiff","title":"ExaPF.AutoDiff.getpartials_kernel!","text":"getpartials_kernel!(compressedJ, t1sF)\n\nCalling the partial extraction kernel. Extract the partials from the AutoDiff dual type on the target device and put it in the compressed Jacobian compressedJ.\n\n\n\n\n\n","category":"function"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.uncompress_kernel!","page":"AutoDiff","title":"ExaPF.AutoDiff.uncompress_kernel!","text":"uncompress_kernel!(J, compressedJ, coloring)\n\nUncompress the compressed Jacobian matrix from compressedJ to sparse CSC (on the CPU) or CSR (on the GPU).\n\n\n\n\n\n","category":"function"},{"location":"lib/autodiff.html#Hessian","page":"AutoDiff","title":"Hessian","text":"","category":"section"},{"location":"lib/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"AbstractHessian\nHessian\nadj_hessian_prod!","category":"page"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.AbstractHessian","page":"AutoDiff","title":"ExaPF.AutoDiff.AbstractHessian","text":"AbstractHessian\n\nAutomatic differentiation for the adjoint-Hessian-vector product λ^ H v of any nonlinear constraint h(x).\n\n\n\n\n\n","category":"type"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.Hessian","page":"AutoDiff","title":"ExaPF.AutoDiff.Hessian","text":"AutoDiff.Hessian\n\nCreates an object for computing Hessian adjoint tangent projections.\n\nfunc::Func: base function to differentiate.\nhost_t1sseeds::VHP: Seeding vector for seeding on the host.\nt1sseeds::VP: The seeding vector for AD built based on the coloring.\nx::VT: Input array of passive type. This includes both state and control.\nt1sF::VD: Output array of active (AD) type.\n∂t1sF::VD: Adjoint of the output array.\nt1sx::VD: Input array of active type.\n∂t1sx::VD: Adjoint of the input array.\nmap::VI: State and control mapping to array x\nvarx::SubT: View of map on x\nt1svarx::SubD: Active (AD) view of map on x\nbuffer::Buff: cache for computing the adjoint (could be Nothing)\n\n\n\n\n\n","category":"type"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.adj_hessian_prod!","page":"AutoDiff","title":"ExaPF.AutoDiff.adj_hessian_prod!","text":"adj_hessian_prod!(form::AbstractFormulation, H::AutoDiff.AbstractHessian, hv, x, λ, v)\n\nCompute the adjoint-Hessian-vector product λ^ H v at a given point x, and store the result inplace in vector hv.\n\n\n\n\n\n","category":"function"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"CurrentModule = ExaPF\nDocTestSetup = quote\n    using ExaPF\n    const PS = ExaPF.PowerSystem\nend\nDocTestFilters = [r\"ExaPF\"]","category":"page"},{"location":"man/powersystem.html#PowerSystem","page":"PowerSystem","title":"PowerSystem","text":"","category":"section"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"The main goal of ExaPF.jl is the solution of optimization problems for electrical power systems in the steady state. The first step in this process is the creation of an object that describes the physics and topology of the power system which ultimately will be mapped into an abstract mathematical optimization problem. In this section we briefly review the power system in the steady state and describe the tools to create and examine power systems in ExaPF.jl.","category":"page"},{"location":"man/powersystem.html#Description","page":"PowerSystem","title":"Description","text":"","category":"section"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"The electrical power system is represented as a linear, lumped network which has to satisfy the Kirchhoff laws:","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"    bmi = bmYbmv ","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"where bmi bmv in mathbbC^N_B are the current and voltage vectors associated to the system and bmY in mathbbC^N_B times N_B is the admittance matrix. These equations are often rewritten in terms of apparent powers:","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"    bms = bmp + jbmq = textitdiag(bmv^*) bmYbmv","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"Using polar representation of the voltage vector, such as bmv = ve^j theta, each bus i=1 cdots N_B  must satisfy the power balance equations:","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"beginaligned\n    p_i = v_i sum_j^n v_j (g_ijcos(theta_i - theta_j) + b_ijsin(theta_i - theta_j))  \n    q_i = v_i sum_j^n v_j (g_ijsin(theta_i - theta_j) - b_ijcos(theta_i - theta_j)) \nendaligned","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"where each bus i has variables p_i q_i v_i theta_i and the topology of the network is defined by a non-negative value of the admittance between two buses i and j, y_ij = g_ij + ib_ij.","category":"page"},{"location":"man/powersystem.html#The-PowerNetwork-Object","page":"PowerSystem","title":"The PowerNetwork Object","text":"","category":"section"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"Currently we can create a PowerNetwork object by parsing a MATPOWER data file.","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"julia> ps = PowerSystem.PowerNetwork(\"data/case9.m\")","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"Apart of MATPOWER data file, PSSE data file are also supported:","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"julia> ps = PowerSystem.PowerNetwork(\"data/case14.raw\")","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"If we print the object, we will obtain bus information, initial voltage, and power that we read from the data file.","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"julia> println(ps)\nPower Network characteristics:\n    Buses: 9. Slack: 1. PV: 2. PQ: 6\n    Generators: 3.\n    ==============================================\n    BUS      TYPE    VMAG    VANG    P   Q\n    ==============================================\n    1     3      1.000  0.00    0.000   0.000\n    2     2      1.000  0.00    1.630   0.000\n    3     2      1.000  0.00    0.850   0.000\n    4     1      1.000  0.00    0.000   0.000\n    5     1      1.000  0.00    -0.900  -0.300\n    6     1      1.000  0.00    0.000   0.000\n    7     1      1.000  0.00    -1.000  -0.350\n    8     1      1.000  0.00    0.000   0.000\n    9     1      1.000  0.00    -1.250  -0.500","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"then, using multiple dispatch, we have defined a set of abstract data types and getter functions which allow us to retrieve information from the PowerNetwork object","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"julia> PowerSystem.get(ps, PowerSystem.NumberOfPQBuses())\n6\njulia> PowerSystem.get(ps, PowerSystem.NumberOfPVBuses())\n2\njulia> PowerSystem.get(ps, PowerSystem.NumberOfSlackBuses())\n1","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"CurrentModule = ExaPF\nDocTestSetup = quote\n    using ExaPF\n    const Precondition = ExaPF.Precondition\n    const Iterative = ExaPF.Iterative\nend\nDocTestFilters = [r\"ExaPF\"]","category":"page"},{"location":"man/linearsolver.html#Linear-Solver","page":"Linear Solver","title":"Linear Solver","text":"","category":"section"},{"location":"man/linearsolver.html#Overview","page":"Linear Solver","title":"Overview","text":"","category":"section"},{"location":"man/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"As mentioned before, a linear solver is required to compute the Newton step in","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"dx .= jacobian(x)\\f(x)","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"Our package supports the following linear solvers:","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"cuSOLVER with csrlsvqr (GPU),\nKrylov.jl with dqgmres and bicgstab (CPU/GPU),\nIterativeSolvers.jl with bicgstab (CPU),\nUMFPACK through the default Julia \\ operator (CPU),\ngeneric BiCGSTAB implementation [Vorst1992] (CPU/GPU),\nor any linear solver wrapped in LinearAlgebra.","category":"page"},{"location":"man/linearsolver.html#Preconditioning","page":"Linear Solver","title":"Preconditioning","text":"","category":"section"},{"location":"man/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"Using only an iterative solver leads to divergence and bad performance due to ill-conditioning of the Jacobian. This is a known phenomenon in power systems. That's why this package comes with a block Jacobi preconditioner that is tailored towards GPUs and is proven to work well with power flow problems.","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"The Jacobian is partitioned into a dense block diagonal structure using Metis.jl, where each block is inverted to build our preconditioner P.","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"(Image: Dense block Jacobi preconditioner \\label{fig:preconditioner})","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"Compared to incomplete Cholesky and incomplete LU this preconditioner is easily portable to the GPU if the number of blocks is high enough. ExaPF.jl uses the batch BLAS calls from cuBLAS to invert the single blocks.","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"CUDA.@sync pivot, info = CUDA.CUBLAS.getrf_batched!(blocks, true)\nCUDA.@sync pivot, info, p.cuJs = CUDA.CUBLAS.getri_batched(blocks, pivot)","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"Assuming that other vendors will provide such batched BLAS APIs, this code is portable to other GPU architectures.","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"[Vorst1992]: Vorst, H. A. van der. 1992. “Bi-Cgstab: A Fast and Smoothly Converging Variant of Bi-Cg for the Solution of Nonsymmetric Linear Systems.”SIAM Journal on Scientific and Statistical Computing 13 (2): 631–44","category":"page"},{"location":"man/evaluators.html#Evaluators","page":"Evaluators","title":"Evaluators","text":"","category":"section"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"In ExaPF.jl, the evaluators are the final layer of the structure. They take as input a given ExaPF.AbstractFormulation and implement the callbacks for the optimization solvers.","category":"page"},{"location":"man/evaluators.html#Overview-of-the-AbstractNLPEvaluator","page":"Evaluators","title":"Overview of the AbstractNLPEvaluator","text":"","category":"section"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"An ExaPF.AbstractNLPEvaluator implements an optimization problem associated with an underlying ExaPF.AbstractFormulation:","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"beginaligned\nmin_u in mathbbR^n               f(u)     \ntextsubject to quad  g(u) = 0 \n                         h(u) leq 0\nendaligned","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"with f mathbbR^n to mathbbR the objective function, g mathbbR^n to mathbbR^m_E non-linear equality constraints and h mathbbR^n to mathbbR^m_I non-linear inequality constraints.","category":"page"},{"location":"man/evaluators.html#Callbacks","page":"Evaluators","title":"Callbacks","text":"","category":"section"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"Most non-linear optimization algorithms rely on callbacks to pass information about the structure of the problem to the optimizer. In ExaPF, the implementation of the evaluators allows to have a proper splitting between the model (formulated in the ExaPF.AbstractFormulation layer) and the optimization algorithms. By design, the implementation of an ExaPF.AbstractNLPEvaluator shares a similar spirit with the implementations introduced in other packages, as","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"MathOptInterface.jl's AbstractNLPEvaluator\nNLPModels' AbstractNLPModel","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"Internally, the evaluator caches all the information needed to evaluate the callbacks (e.g. the polar representation of the problem, with voltage magnitudes and angles). This cache allows to reduce the number of memory allocations to its minimum. Once a new variable u passed to the evaluator a function ExaPF.update! is being called to update the cache, according to the model specified in the underlying ExaPF.AbstractFormulation. Denoting by nlp an instance of AbstractNLPEvaluator, the cache is updated via","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"julia> ExaPF.update!(nlp, u)","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"Once the internal structure updated, we are ready to call the different callbacks, in every order. For instance, computing the objective, the gradient and the constraints amounts to","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"# Objective\njulia> obj = ExaPF.objective(nlp, u)\n# Gradient\njulia> g = zeros(n_variables(nlp))\njulia> ExaPF.gradient!(nlp, g, u)\n# Constraints\njulia> cons = zeros(n_constraints(nlp))\njulia> ExaPF.constraint!(nlp, cons, u)\n","category":"page"},{"location":"man/evaluators.html#A-journey-to-the-reduced-space-with-the-ReducedSpaceEvaluator","page":"Evaluators","title":"A journey to the reduced space with the ReducedSpaceEvaluator","text":"","category":"section"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"When we aim at optimizing the problem directly in the powerflow manifold, the ExaPF.ReducedSpaceEvaluator is our workhorse. We recall that the powerflow manifold is defined implicitly by the powerflow equations:","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"    g(x(u) u) = 0","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"By design, the ExaPF.ReducedSpaceEvaluator works in the reduced space (x(u) u). Hence, the reduced optimization problem writes out","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"beginaligned\nmin_u in mathbbR^n   f(x(u) u) \ntextsubject to quad       h(x(u) u) leq 0\nendaligned","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"This formulation comes with two advantages:","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"if the dimension of the state is large, the reduced problem has a lower dimension.\nthe powerflow equality constraints g(x u) = 0 disappear in the reduced problem.","category":"page"},{"location":"man/evaluators.html#Playing-with-the-ReducedSpaceEvaluator","page":"Evaluators","title":"Playing with the ReducedSpaceEvaluator","text":"","category":"section"},{"location":"man/evaluators.html#Constructor","page":"Evaluators","title":"Constructor","text":"","category":"section"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"To create a ExaPF.ReducedSpaceEvaluator, we just need a polar formulation polar::PolarForm:","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"julia> nlp = ExaPF.ReducedSpaceEvaluator(polar)\n","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"or we could alternatively instantiate the evaluator directly from a MATPOWER (or PSSE) instance:","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"julia> datafile = \"case9.m\"\njulia> nlp = ExaPF.ReducedSpaceEvaluator(datafile)\nA ReducedSpaceEvaluator object\n    * device: KernelAbstractions.CPU()\n    * #vars: 5\n    * #cons: 10\n    * constraints:\n        - voltage_magnitude_constraints\n        - active_power_constraints\n        - reactive_power_constraints\n    * linear solver: ExaPF.LinearSolvers.DirectSolver()\n","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"Let's describe the output of the last command.","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"device: KernelAbstractions.CPU(): the evaluator is instantiated on the CPU ;\n#vars: 5: it has 5 optimization variables ;\n#cons: 10: and 10 inequality constraints ;\nconstraints: by default, nlp comes with three inequality constraints: voltage_magnitude_constraints (specifying the bounds x_L leq x(u) leq x_U on the state x), active_power_constraints and reactive_power_constraints (bounding the active and reactive power of the generators) ;\nlinear solver: ExaPF.LinearSolvers.DirectSolver: to solve the linear systems, the evaluator uses a direct linear algebra solver.","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"Of course, these settings are only specified by default. The user is free to choose the parameters she wants. For instance,","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"We could remove all constraints by passing an empty array of constraints to the evaluator:\njulia> constraints = Function[]\njulia> nlp = ExaPF.ReducedSpaceEvaluator(datafile; constraints=constraints)\nWe could load the evaluator on the GPU simply by changing the device option:\njulia> nlp = ExaPF.ReducedSpaceEvaluator(datafile; device=CUDADevice())","category":"page"},{"location":"man/evaluators.html#Caching","page":"Evaluators","title":"Caching","text":"","category":"section"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"To juggle between the mathematical description (characterized by a state x and a control u) and the physical description (characterized by the voltage and power injection at each bus), the evaluator nlp stores internally a cache nlp.buffer, with type ExaPF.AbstractNetworkBuffer.","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"julia> buffer = get(nlp, ExaPF.PhysicalState())","category":"page"},{"location":"man/evaluators.html#Evaluation-of-the-callbacks","page":"Evaluators","title":"Evaluation of the callbacks","text":"","category":"section"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"Now that we have a nlp evaluator available, we can embed it in any optimization routine. For instance, suppose we have a new control uk available. First, we need to find the corresponding state xk, such that g(x_k u_k) = 0. In the evaluator's API, this sums up to:","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"ExaPF.update!(nlp, uk)\n","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"The function update! will","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"Feed the physical description nlp.buffer with the values stored in the new control uk.\nSolve the powerflow equations corresponding to the formulation specified in form. This operation updates the cache nlp.buffer inplace.","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"Once the function update! called (and only after that), we can evaluate all the different callbacks, independently of one other.","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"Objective\njulia> cost = ExaPF.objective(nlp, uk)\nObjective's gradient\njulia> g = zeros(n_variables(nlp))\njulia> ExaPF.gradient!(nlp, g, uk)\nConstraints\n# Evaluate constraints\njulia> cons = zeros(n_constraints(nlp))\njulia> ExaPF.constraint!(nlp, cons, uk)\nConstraints' Jacobian\n## Evaluate Jacobian\njulia> ExaPF.jacobian!(nlp, jac, uk)\nConstraints' Jacobian-vector product:\n## Evaluate Jacobian-vector product\njulia> v = zeros(n_variables(nlp))\njulia> jv = zeros(n_constraints(nlp))\njulia> ExaPF.jprod!(nlp, jv, uk, v)\nConstraints' transpose Jacobian-vector product\n## Evaluate transpose Jacobian-vector product\njulia> v = zeros(n_constraints(nlp))\njulia> jv = zeros(n_variables(nlp))\njulia> ExaPF.jtprod!(nlp, jv, uk, v)\nHessian-vector product:\n## Evaluate transpose Jacobian-vector product\njulia> v = zeros(n_variables(nlp))\njulia> hv = zeros(n_variables(nlp))\njulia> ExaPF.hessprod!(nlp, hv, uk, v)\nHessian:\n## Evaluate transpose Jacobian-vector product\njulia> H = zeros(n_variables(nlp), n_variables(nlp))\njulia> ExaPF.hessprod!(nlp, H, uk)","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"note: Note\nOnce the powerflow equations solved in a update! call, the solution x_k is stored implicitly in nlp.buffer. These values will be used as a starting point for the next resolution of powerflow equations.","category":"page"},{"location":"man/evaluators.html#Passing-the-problem-to-an-optimization-solver-with-MathOptInterface","page":"Evaluators","title":"Passing the problem to an optimization solver with MathOptInterface","text":"","category":"section"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"ExaPF.jl provides a utility to pass the non-linear structure specified by a ExaPF.AbstractNLPEvaluator to a MathOptInterface (MOI) optimization problem. That allows to solve the corresponding optimal power flow problem using any non-linear optimization solver compatible with MOI.","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"For instance, we can solve the reduced problem specified in nlp with Ipopt. In a few lines of code:","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"using Ipopt\noptimizer = Ipopt.Optimizer()\nMOI.set(optimizer, MOI.RawParameter(\"print_level\"), 5)\nMOI.set(optimizer, MOI.RawParameter(\"limited_memory_max_history\"), 50)\nMOI.set(optimizer, MOI.RawParameter(\"hessian_approximation\"), \"limited-memory\")\nsolution = ExaPF.optimize!(optimizer, nlp)\nMOI.empty!(optimizer)\n","category":"page"},{"location":"man/benchmark.html","page":"Benchmark","title":"Benchmark","text":"CurrentModule = ExaPF\nDocTestSetup = quote\n    using ExaPF\nend\nDocTestFilters = [r\"ExaPF\"]","category":"page"},{"location":"man/benchmark.html#Benchmark","page":"Benchmark","title":"Benchmark","text":"","category":"section"},{"location":"man/benchmark.html","page":"Benchmark","title":"Benchmark","text":"For the purpose of performance regression testing, ExaPF provides a lightweight benchmark script. It allows to test the various configurations for the linear solvers used in the Newton-Raphson algorithm, and run them on a specific hardware. The main julia script benchmark/benchmarks.jl takes all its options from the command line. The benchmark script takes as input a linear solver (e.g. KrylovBICGSTAB), a target architecture as a KernelAbstractions object (CPU or CUDADevice), and a case filename in (e.g. data/case9.m). An exhaustive list of all available linear solvers can be obtained via ExaPF.LinearSolvers.list_solvers.","category":"page"},{"location":"man/benchmark.html","page":"Benchmark","title":"Benchmark","text":"Running","category":"page"},{"location":"man/benchmark.html","page":"Benchmark","title":"Benchmark","text":"julia --project benchmark/benchmarks.jl KrylovBICGSTAB CUDADevice case300.m","category":"page"},{"location":"man/benchmark.html","page":"Benchmark","title":"Benchmark","text":"yields","category":"page"},{"location":"man/benchmark.html","page":"Benchmark","title":"Benchmark","text":"KrylovBICGSTAB, CUDADevice, case300.m,  69.0,  3.57,  43.7, true","category":"page"},{"location":"man/benchmark.html","page":"Benchmark","title":"Benchmark","text":"The first three fields are the settings of the benchmark run. They are followed by three timings in milliseconds:","category":"page"},{"location":"man/benchmark.html","page":"Benchmark","title":"Benchmark","text":"the time taken by the Newton-Raphson algorithm to solve the power flow,\nthe timings for the Jacobian accumulation using AutoDiff,\nand the time for the linear solver, including the preconditioner.","category":"page"},{"location":"man/benchmark.html","page":"Benchmark","title":"Benchmark","text":"To acquire these timings the code is run three times to avoid any precompilation effects. The last field confirms the Newton-Raphson convergence. In case more verbose output is desired, one has to manually set the verbosity in benchmark/benchmarks.jl by changing","category":"page"},{"location":"man/benchmark.html","page":"Benchmark","title":"Benchmark","text":"powerflow_solver = NewtonRaphson(tol=ntol)","category":"page"},{"location":"man/benchmark.html","page":"Benchmark","title":"Benchmark","text":"to one of the following options:","category":"page"},{"location":"man/benchmark.html","page":"Benchmark","title":"Benchmark","text":"powerflow_solver = NewtonRaphson(tol=ntol, verbose=VERBOSE_LEVEL_NONE)\npowerflow_solver = NewtonRaphson(tol=ntol, verbose=VERBOSE_LEVEL_LOW)\npowerflow_solver = NewtonRaphson(tol=ntol, verbose=VERBOSE_LEVEL_MEDIUM)\npowerflow_solver = NewtonRaphson(tol=ntol, verbose=VERBOSE_LEVEL_HIGH)","category":"page"},{"location":"man/benchmark.html","page":"Benchmark","title":"Benchmark","text":"A shell script benchmark/benchmarks.sh is provided to gather timings with various canonical configurations and storing them in a file cpu_REV.log and gpu_REF.log, where REV is the sha1 hash of the current checked out ExaPF version.","category":"page"},{"location":"man/formulations.html#Formulations","page":"Formulations","title":"Formulations","text":"","category":"section"},{"location":"man/formulations.html#Overview","page":"Formulations","title":"Overview","text":"","category":"section"},{"location":"quickstart.html#Quick-Start","page":"Quick start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"This page introduces the first steps to set up ExaPF.jl. We show how to load a power network instance and how to solve the power flow equations both on the CPU and on the GPU. The full script is implemented in test/quickstart.jl","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"We start by importing CUDA and KernelAbstractions:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"using CUDA\nusing KernelAbstractions","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Then, we load ExaPF and its submodules with","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"using ExaPF\nimport ExaPF: AutoDiff\nconst PS = ExaPF.PowerSystem\nconst LS = ExaPF.LinearSolvers","category":"page"},{"location":"quickstart.html#Short-version","page":"Quick start","title":"Short version","text":"","category":"section"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Imagine you want to load an instance from the pglib-opf benchmark, stored in the current folder:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"pglib_instance = \"data/case1354.m\"","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"The powerflow equations can be solved in three lines of code, as","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"polar = ExaPF.PolarForm(pglib_instance, CPU())\npf_algo = NewtonRaphson(; verbose=0, tol=1e-10)\nconvergence = ExaPF.powerflow(polar, pf_algo)\nIteration 0. Residual norm: 26.6667.\nIteration 1. Residual norm: 15.0321.\nIteration 2. Residual norm: 0.588264.\nIteration 3. Residual norm: 0.00488507.\nIteration 4. Residual norm: 1.39924e-06.\nIteration 5. Residual norm: 7.37136e-12.","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Implicitly, ExaPF has just proceed to the following operations:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"instantiate automatically a starting point x_0 from MATPOWER's data\ninstantiate the Jacobian of the powerflow equations using AutoDiff.\nsolve the powerflow equations iteratively, using a Newton-Raphson algorithm.","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"This compact syntax allows to solve quickly any powerflow equations in a few lines a code. However, in most case, the user may want more coarse grained control on the different objects manipulated.","category":"page"},{"location":"quickstart.html#Detailed-version","page":"Quick start","title":"Detailed version","text":"","category":"section"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"In what follows, we detail step by step the detailed procedure to solve the powerflow equations.","category":"page"},{"location":"quickstart.html#How-to-load-a-MATPOWER-instance-as-a-PowerNetwork-object?","page":"Quick start","title":"How to load a MATPOWER instance as a PowerNetwork object?","text":"","category":"section"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"We start by importing a MATPOWER instance to a ExaPF.PowerSystem.PowerNetwork object:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"pf = PS.PowerNetwork(pglib_instance)","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"The different fields of the object pf specify the characteristics of the network. For instance, we could retrieve the number of buses or get the indexing of the PV buses with","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"nbus = PS.get(pf, PS.NumberOfBuses())\npv_indexes = PS.get(pf, PS.PVIndexes())","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"However, a ExaPF.PowerSystem.PowerNetwork object stores only the physical attributes of the network, independently of the mathematical formulations we could use to model the network. To choose a particular formulation, we need to pass the object pf to an ExaPF.AbstractFormulation layer. Currently, the only layer implemented is the polar formulation, with the ExaPF.PolarForm structure. In the future, other formulations (e.g. RectangularForm) may be implemented as well.","category":"page"},{"location":"quickstart.html#How-to-solve-the-powerflow-equations?","page":"Quick start","title":"How to solve the powerflow equations?","text":"","category":"section"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"To solve the powerflow equations, we need to choose a given mathematical formulation for the equations of the network. To each formulation corresponds a given state x and control u. Using polar representation of the voltage vector, such as bmv = ve^j theta, each bus i=1 cdots N_B must satisfy the power balance equations:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"beginaligned\n    p_i = v_i sum_j^n v_j (g_ijcos(theta_i - theta_j) + b_ijsin(theta_i - theta_j))  \n    q_i = v_i sum_j^n v_j (g_ijsin(theta_i - theta_j) - b_ijcos(theta_i - theta_j)) \nendaligned","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"The powerflow equations rewrite in the abstract mathematical formalism:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"g(x u) = 0","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"For a given control u, solving the powerflow equations resumes to find a state x(u) such that g(x(u) u) = 0.","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"To this goal, ExaPF.jl implements a Newton-Raphson algorithm that allows to solve the powerflow equations in a few lines of code. We first instantiate a PolarForm object to adopt a polar formulation as a model:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"polar = ExaPF.PolarForm(pf, CPU())\n","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Note that the constructor ExaPF.PolarForm takes as input a ExaPF.PowerSystem.PowerNetwork object and a KernelAbstractions.jl device (here set to CPU() by default). We will explain in the next section how to load a ExaPF.PolarForm object on the GPU with the help of a CUDADevice().","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"The Newton-Raphson solves the equation g(x u) = 0 in an iterative fashion. The algorithm solves at each step the linear equation:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"    x_k+1 = - (nabla_x g_k)^-1 g(x_k u)","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Hence, the algorithm requires the following elements:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"an initial position x_0\na function to solve efficiently the linear system (nabla_x g_k) x_k+1 = g(x_k u)\na function to evaluate the Jacobian nabla_x g_k","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"that translate to the Julia code:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"physical_state = get(polar, ExaPF.PhysicalState())\nExaPF.init_buffer!(polar, physical_state) # populate values inside buffer\nlinear_solver = LS.DirectSolver()","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"We build a Jacobian object storing all structures needed by the AutoDiff backend:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"julia> jx = AutoDiff.Jacobian(polar, ExaPF.power_balance, State())","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Let's explain further these three objects.","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"physical_state is a AbstractPhysicalCache storing all the physical values attached to the formulation polar::PolarForm.\njx is a Jacobian structure which allows the solver to compute efficiently the Jacobian of the powerflow equations nabla_x g using AutoDiff.\nlinear_solver specifies the linear algorithm uses to solve the linear system (nabla_x g_k) x_k+1 = g(x_k u). By default, we use direct linear algebra.","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"In the AutoDiff Jacobian jx, the evaluation of the Jacobian J is stored in jx.J:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"jac = jx.J","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"This matrix is at the basis of the powerflow algorithm. At each iteration, the AutoDiff backend updates the values in the Jacobian jx, then we take the updated matrix jx.J to evaluate the","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"The procedure is implemented in the powerflow function, which uses a Newton-Raphson algorithm to solve the powerflow equations. The Newton-Raphson algorithm is specified as:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"pf_algo = NewtonRaphson(; verbose=1, tol=1e-10)","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Then, we could solve the powerflow equations simply with","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"convergence = ExaPF.powerflow(polar, jx, physical_state, pf_algo;\n                              linear_solver=linear_solver)\nIteration 0. Residual norm: 26.6667.\nIteration 1. Residual norm: 15.0321.\nIteration 2. Residual norm: 0.588264.\nIteration 3. Residual norm: 0.00488507.\nIteration 4. Residual norm: 1.39924e-06.\nIteration 5. Residual norm: 7.37136e-12.","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Here, the algorithm solves the powerflow equations in 5 iterations. The algorithm modifies the values of physical_state inplace, to avoid any unnecessary memory allocations.","category":"page"},{"location":"quickstart.html#How-to-deport-the-computation-on-the-GPU?","page":"Quick start","title":"How to deport the computation on the GPU?","text":"","category":"section"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Now, how could we deport the resolution on the GPU? The procedure looks exactly the same. It suffices to initiate a new ExaPF.PolarForm object, but on the GPU:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"polar_gpu = ExaPF.PolarForm(pf, CUDADevice())\n","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"polar_gpu will load all the structures it needs on the GPU, to avoid unnecessary movements between the host and the device. We could load the other structures directly on the GPU with:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"physical_state_gpu = get(polar, ExaPF.PhysicalState())\nExaPF.init_buffer!(polar_gpu, physical_state_gpu) # populate values inside buffer\njx_gpu = AutoDiff.Jacobian(polar_gpu, ExaPF.power_balance, State())\nlinear_solver = DirectSolver()","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Then, solving the powerflow equations on the GPU is straightforward","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"convergence = ExaPF.powerflow(polar_gpu, jx_gpu, physical_state_gpu, pf_algo;\n                              linear_solver=linear_solver)","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"yielding the output","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Iteration 0. Residual norm: 26.6667.\nIteration 1. Residual norm: 15.0321.\nIteration 2. Residual norm: 0.588264.\nIteration 3. Residual norm: 0.00488507.\nIteration 4. Residual norm: 1.39924e-06.\nIteration 5. Residual norm: 7.94916e-12.","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Note that we get the same convergence pattern as on the CPU.","category":"page"},{"location":"quickstart.html#How-to-solve-the-linear-system-with-BICGSTAB?","page":"Quick start","title":"How to solve the linear system with BICGSTAB?","text":"","category":"section"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"By default, the algorithm runs with a direct solver, which might be inefficient for large problems. To overcome this issue, ExaPF implements a wrapper for different iterative algorithms (GMRES, BICGSTAB).","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"The performance of iterative solvers is usually improved if we use a preconditioner. ExaPF.jl implements a block-Jacobi preconditioner, tailored for GPU usage. To build an instance with 8 blocks, just write","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"npartitions = 8\nprecond = LS.BlockJacobiPreconditioner(jac, npartitions, CUDADevice())","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"You could define an iterative solver preconditioned with precond simply as:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"linear_solver = ExaPF.KrylovBICGSTAB(precond)\n","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"(this will use the BICGSTAB algorithm implemented in Krylov.jl). By default, the tolerance of BICGSTAB is set to 1e-10:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"linear_solver.atol # 1e-10","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"We need to update accordingly the tolerance of the Newton-Raphson algorithm, as it could not be lower than the tolerance of the iterative solver.","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"pf_algo = NewtonRaphson(; verbose=1, tol=1e-7)","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Calling","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"convergence = ExaPF.powerflow(polar_gpu, jx_gpu, physical_state_gpu, pf_algo;\n                              linear_solver=linear_solver)","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"yields","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Iteration 0. Residual norm: 26.6667.\nIteration 1. Residual norm: 15.0321.\nIteration 2. Residual norm: 0.588264.\nIteration 3. Residual norm: 0.00488507.\nIteration 4. Residual norm: 1.39925e-06.\nIteration 5. Residual norm: 1.81445e-09.\n","category":"page"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"CurrentModule = ExaPF.PowerSystem","category":"page"},{"location":"lib/powersystem.html#PowerSystem","page":"PowerSystem","title":"PowerSystem","text":"","category":"section"},{"location":"lib/powersystem.html#Description","page":"PowerSystem","title":"Description","text":"","category":"section"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"AbstractPowerSystem\nPowerNetwork","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.AbstractPowerSystem","page":"PowerSystem","title":"ExaPF.PowerSystem.AbstractPowerSystem","text":"AbstractPowerSystem\n\nFirst layer of the package. Store the topology of a given transmission network, including:\n\nthe power injection at each bus ;\nthe admittance matrix ;\nthe default voltage at each bus.\n\nData are imported either from a matpower file, or a PSSE file.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.PowerNetwork","page":"PowerSystem","title":"ExaPF.PowerSystem.PowerNetwork","text":"PowerNetwork <: AbstractPowerSystem\n\nThis structure contains constant parameters that define the topology and physics of the power network.\n\nThe object PowerNetwork uses its own contiguous indexing for the buses. The indexing is independent from those specified in the Matpower or the PSSE input file. However, a correspondence between the two indexing (Input indexing to PowerNetwork indexing) is stored inside the attribute bus_to_indexes.\n\nNote\n\nThe object PowerNetwork is created in the host memory. Use a AbstractFormulation object to move data to the target device.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#API-Reference","page":"PowerSystem","title":"API Reference","text":"","category":"section"},{"location":"lib/powersystem.html#Network-elements","page":"PowerSystem","title":"Network elements","text":"","category":"section"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"AbstractNetworkElement","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.AbstractNetworkElement","page":"PowerSystem","title":"ExaPF.PowerSystem.AbstractNetworkElement","text":"AbstractNetworkElement\n\nAbstraction for all physical elements being parts of a AbstractPowerSystem. Elements are divided in\n\ntransmission lines (Lines)\nbuses (Buses)\ngenerators (Generators)\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"List of elements:","category":"page"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"Buses\nLines\nGenerators","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.Buses","page":"PowerSystem","title":"ExaPF.PowerSystem.Buses","text":"Buses <: AbstractNetworkElement\n\nBuses of a transmission network.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.Lines","page":"PowerSystem","title":"ExaPF.PowerSystem.Lines","text":"Lines <: AbstractNetworkElement\n\nLines of a transmission network.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.Generators","page":"PowerSystem","title":"ExaPF.PowerSystem.Generators","text":"Generators <: AbstractElement\n\nGenerators in a transmission network\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#Network-attributes","page":"PowerSystem","title":"Network attributes","text":"","category":"section"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"AbstractNetworkAttribute","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.AbstractNetworkAttribute","page":"PowerSystem","title":"ExaPF.PowerSystem.AbstractNetworkAttribute","text":"AbstractNetworkAttribute\n\nAttribute of a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"List of attributes:","category":"page"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"NumberOfBuses\nNumberOfLines\nNumberOfGenerators\nNumberOfPVBuses\nNumberOfPQBuses\nNumberOfSlackBuses\nBaseMVA\nBusAdmittanceMatrix","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.NumberOfBuses","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfBuses","text":"NumberOfBuses <: AbstractNetworkAttribute\n\nNumber of buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.NumberOfLines","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfLines","text":"NumberOfLines <: AbstractNetworkAttribute\n\nNumber of lines in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.NumberOfGenerators","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfGenerators","text":"NumberOfGenerators <: AbstractNetworkAttribute\n\nNumber of generators in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.NumberOfPVBuses","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfPVBuses","text":"NumberOfPVBuses <: AbstractNetworkAttribute\n\nNumber of PV buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.NumberOfPQBuses","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfPQBuses","text":"NumberOfPQBuses <: AbstractNetworkAttribute\n\nNumber of PQ buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.NumberOfSlackBuses","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfSlackBuses","text":"NumberOfSlackBuses <: AbstractNetworkAttribute\n\nNumber of slack buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.BaseMVA","page":"PowerSystem","title":"ExaPF.PowerSystem.BaseMVA","text":"BaseMVA <: AbstractNetworkAttribute\n\nBase MVA of the network.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.BusAdmittanceMatrix","page":"PowerSystem","title":"ExaPF.PowerSystem.BusAdmittanceMatrix","text":"BusAdmittanceMatrix <: AbstractNetworkAttribute\n\nBus admittance matrix associated with the topology of the network.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"Query the indexing of the different elements in a given network:","category":"page"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"PVIndexes\nPQIndexes\nSlackIndexes\nGeneratorIndexes\n","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.PVIndexes","page":"PowerSystem","title":"ExaPF.PowerSystem.PVIndexes","text":"PVIndexes <: AbstractIndexing\n\nIndexes of the PV buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.PQIndexes","page":"PowerSystem","title":"ExaPF.PowerSystem.PQIndexes","text":"PQIndexes <: AbstractIndexing\n\nIndexes of the PQ buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.SlackIndexes","page":"PowerSystem","title":"ExaPF.PowerSystem.SlackIndexes","text":"SlackIndexes <: AbstractIndexing\n\nIndexes of the slack buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.GeneratorIndexes","page":"PowerSystem","title":"ExaPF.PowerSystem.GeneratorIndexes","text":"GeneratorIndexes <: AbstractIndexing\n\nIndexes of the generators in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#Network-values","page":"PowerSystem","title":"Network values","text":"","category":"section"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"AbstractNetworkValues","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.AbstractNetworkValues","page":"PowerSystem","title":"ExaPF.PowerSystem.AbstractNetworkValues","text":"AbstractNetworkValues\n\nNumerical values attached to the different attributes of the network.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"List of values:","category":"page"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"VoltageMagnitude\nVoltageAngle\nActivePower\nReactivePower\nActiveLoad\nReactiveLoad\n","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.VoltageMagnitude","page":"PowerSystem","title":"ExaPF.PowerSystem.VoltageMagnitude","text":"VoltageMagnitude <: AbstractNetworkValues\n\nMagnitude |v| of the voltage v = |v| exp(i θ).\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.VoltageAngle","page":"PowerSystem","title":"ExaPF.PowerSystem.VoltageAngle","text":"VoltageAngle <: AbstractNetworkValues\n\nAngle θ of the voltage v = |v| exp(i θ).\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.ActivePower","page":"PowerSystem","title":"ExaPF.PowerSystem.ActivePower","text":"ActivePower <: AbstractNetworkValues\n\nActive power P of the complex power S = P + iQ.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.ReactivePower","page":"PowerSystem","title":"ExaPF.PowerSystem.ReactivePower","text":"ReactivePower <: AbstractNetworkValues\n\nReactive power Q of the complex power S = P + iQ.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.ActiveLoad","page":"PowerSystem","title":"ExaPF.PowerSystem.ActiveLoad","text":"ActiveLoad <: AbstractNetworkValues\n\nActive load Pd at buses.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.ReactiveLoad","page":"PowerSystem","title":"ExaPF.PowerSystem.ReactiveLoad","text":"ReactiveLoad <: AbstractNetworkValues\n\nReactive load Qd at buses.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"Function to get the range of a given value:","category":"page"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"bounds","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.bounds","page":"PowerSystem","title":"ExaPF.PowerSystem.bounds","text":"bounds(pf::AbstractPowerSystem, attr::AbstractNetworkAttribute, val::AbstractNetworkValues)\n\nReturn lower and upper bounds corresponding to the admissible values of the AbstractNetworkAttribute attr.\n\nExamples\n\np_min, p_max = bounds(pf, Generator(), ActivePower())\nv_min, v_max = bounds(pf, Buses(), VoltageMagnitude())\n\n\n\n\n\n\n","category":"function"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"CurrentModule = ExaPF\nDocTestSetup = quote\n    using ExaPF\n    const AD = ExaPF.AD\nend\nDocTestFilters = [r\"ExaPF\"]","category":"page"},{"location":"man/autodiff.html#AutoDiff","page":"AutoDiff","title":"AutoDiff","text":"","category":"section"},{"location":"man/autodiff.html#Overview","page":"AutoDiff","title":"Overview","text":"","category":"section"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"Given a set of equations F(x) = 0, the Newton-Raphson algorithm for solving nonlinear equations (see below) requires the Jacobian J = jacobian(x) of F. At each iteration a new step dx is computed by solving a linear system. In our case J is sparse and indefinite.","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"    go = true\n    while(go)\n        dx .= jacobian(x)\\f(x)\n        x  .= x .- dx\n        go = norm(f(x)) < tol ? true : false\n    end","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"There are two modes of differentiation called forward/tangent or reverse/adjoint. The latter is known in machine learning as backpropagation. The forward mode generates Jacobian-vector product code tgt(x,d) = J(x) * d, while the adjoint mode generates code for the transposed Jacobian-vector product adj(x,y) = (J(x)'*y). We recommend the book Evaluating derivatives: principles and techniques of algorithmic differentiation by Griewank and Walther[1] for a more in-depth introduction to automatic differentiation. The computational complexity of both models favors the adjoint mode if the number of outputs of F is much smaller than the number of inputs size(x) >> size(F), like for example the loss functions in machine learning. However, in our case F is a multivariate vector function from mathbbR^n to mathbbR^n, where n is the number of buses.","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"(Image: Jacobian coloring \\label{fig:coloring})","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"To avoid a complexity of mathcalO(n) cdot cost(F) by letting the tangent mode run over all Cartesian basis vectors of mathbbR^n, we apply the technique of Jacobian coloring to compress the sparse Jacobian J. Running the tangent mode, it allows to compute columns of the Jacobian concurrently, by combining independent columns in one Jacobian-vector evaluation (see in figure above). For sparsity detection we rely on the greedy algorithm implemented by SparseDiffTools.jl.","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"Given the sparsity pattern, the forward model is applied through the package ForwardDiff.jl. Given the number of Jacobian colors c we can build our dual type t1s with c directions:","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"t1s{N} = ForwardDiff.Dual{Nothing,Float64, N} where N}","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"Note that a second-order type t2s can be created naturally by applying the same logic to t1s:","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"t2s{M,N} =  ForwardDiff.Dual{Nothing,t1s{N}, M} where M, N}","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"Finally, this dual type can be ported to both vector types Vector and CuVector:","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"VT = Vector{Float64}\nVT = Vector{t1s{N}}}\nVT = CuVector{t1s{N}}}","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"Setting VT to either of the three types allows us to instantiate code that has been written using the broadcast operator .","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"x .= a .* b","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"or accessed in kernels written for KernelAbstractions.jl like for example the power flow equations (here in polar form):","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"@kernel function residual_kernel!(F, v_m, v_a,\n                                  ybus_re_nzval, ybus_re_colptr, ybus_re_rowval,\n                                  ybus_im_nzval, ybus_im_colptr, ybus_im_rowval,\n                                  pinj, qinj, pv, pq, nbus)\n\n    npv = size(pv, 1)\n    npq = size(pq, 1)\n\n    i = @index(Global, Linear)\n    # REAL PV: 1:npv\n    # REAL PQ: (npv+1:npv+npq)\n    # IMAG PQ: (npv+npq+1:npv+2npq)\n    fr = (i <= npv) ? pv[i] : pq[i - npv]\n    F[i] -= pinj[fr]\n    if i > npv\n        F[i + npq] -= qinj[fr]\n    end\n    @inbounds for c in ybus_re_colptr[fr]:ybus_re_colptr[fr+1]-1\n        to = ybus_re_rowval[c]\n        aij = v_a[fr] - v_a[to]\n        coef_cos = v_m[fr]*v_m[to]*ybus_re_nzval[c]\n        coef_sin = v_m[fr]*v_m[to]*ybus_im_nzval[c]\n        cos_val = cos(aij)\n        sin_val = sin(aij)\n        F[i] += coef_cos * cos_val + coef_sin * sin_val\n        if i > npv\n            F[npq + i] += coef_cos * sin_val - coef_sin * cos_val\n        end\n    end\nend","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"These two abstractions are a powerful tool that allow us to implement the forward mode in vectorized form where the number of directions or tangent components of a tangent variable are the number of Jacobian colors. We illustrate this in the figure below with a point-wise vector product x .* y","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"(Image: SIMD AD for point-wise vector product \\label{fig:simd})","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"This natural way of computing the compressed Jacobian yields a very high performing code that is portable to any vector architecture, given that a similar package like CUDA.jl exists. We note that similar packages for the Intel Compute Engine and AMD ROCm are in development called oneAPI.jl and AMDGPU.jl, respectively. We expect our package to be portable to AMD and Intel GPUs in the future.","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"[1]: Griewank, Andreas, and Andrea Walther. Evaluating derivatives: principles and techniques of algorithmic differentiation. Society for Industrial and Applied Mathematics, 2008.","category":"page"},{"location":"index.html#ExaPF","page":"Home","title":"ExaPF","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"ExaPF.jl is a package to solve the power flow problem on upcoming exascale architectures.  On these architectures the computational performance can only be achieved through graphics processing units (GPUs) as these systems lack substantial computational performance through classical CPUs. ExaPF.jl aims to provide the sensitivity information required for a reduced space optimization method, and enabling the computation of the optimal power flow problem (OPF) fully on GPUs. Reduced space methods enforce the constraints, represented here by the power flow's (PF) system of nonlinear equations, separately at each iteration of the optimization in the reduced space.  This includes the computation of second-order derivatives using automatic differentiation, an iterative linear solver with a preconditioner, and a Newton-Raphson implementation. All of these steps allow us to run the main computational loop entirely on the GPU with no transfer from host to device.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"We leverage the packages CUDA.jl and KernelAbstractions.jl to make ExaPF portable across GPU architectures. autodiff and linear solver illustrate the design overview of ExaPF.jl targeted for GPUs.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The user API is separated into three layers:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"First layer: Physical layer, specify the power network topology in powersystem\nSecond layer: Interface between power network and NLE or NLP in formulations\nThird layer: Evaluators for nonlinear problems","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The third layer is for numerical optimization whereas the first layer provides the physical properties at the electrical engineering level.","category":"page"},{"location":"index.html#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"quickstart.md\",\n]\nDepth=1","category":"page"},{"location":"index.html#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"man/autodiff.md\",\n    \"man/benchmark.md\",\n    \"man/linearsolver.md\",\n    \"man/powersystem.md\",\n    \"man/formulations.md\",\n    \"man/evaluators.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Library","page":"Home","title":"Library","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"lib/autodiff.md\",\n    \"lib/linearsolver.md\",\n    \"lib/powersystem.md\",\n    \"lib/formulations.md\",\n    \"lib/evaluators.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This research was supported by the Exascale Computing Project (17-SC-20-SC), a joint project of the U.S. Department of Energy’s Office of Science and National Nuclear Security Administration, responsible for delivering a capable exascale ecosystem, including software, applications, and hardware technology, to support the nation’s exascale computing imperative.","category":"page"},{"location":"lib/evaluators.html","page":"Evaluators","title":"Evaluators","text":"CurrentModule = ExaPF","category":"page"},{"location":"lib/evaluators.html#Evaluators","page":"Evaluators","title":"Evaluators","text":"","category":"section"},{"location":"lib/evaluators.html#Description","page":"Evaluators","title":"Description","text":"","category":"section"},{"location":"lib/evaluators.html","page":"Evaluators","title":"Evaluators","text":"AbstractNLPEvaluator","category":"page"},{"location":"lib/evaluators.html#ExaPF.AbstractNLPEvaluator","page":"Evaluators","title":"ExaPF.AbstractNLPEvaluator","text":"AbstractNLPEvaluator\n\nAbstractNLPEvaluator implements the bridge between the problem formulation (see AbstractFormulation) and the optimization solver. Once the problem formulation bridged, the evaluator allows to evaluate:\n\nthe objective;\nthe gradient of the objective;\nthe constraints;\nthe Jacobian of the constraints;\nthe Jacobian-vector and transpose-Jacobian vector products of the constraints;\nthe Hessian of the objective;\nthe Hessian of the Lagrangian.\n\n\n\n\n\n","category":"type"},{"location":"lib/evaluators.html#API-Reference","page":"Evaluators","title":"API Reference","text":"","category":"section"},{"location":"lib/evaluators.html#Optimization","page":"Evaluators","title":"Optimization","text":"","category":"section"},{"location":"lib/evaluators.html","page":"Evaluators","title":"Evaluators","text":"optimize!","category":"page"},{"location":"lib/evaluators.html#ExaPF.optimize!","page":"Evaluators","title":"ExaPF.optimize!","text":"optimize!(optimizer, nlp::AbstractNLPEvaluator, x0)\n\nUse optimization routine implemented in optimizer to optimize the optimal power flow problem specified in the evaluator nlp. Initial point is specified by x0.\n\nReturn the solution as a named tuple, with fields\n\nstatus::MOI.TerminationStatus: Solver's termination status, as specified by MOI\nminimum::Float64: final objective\nminimizer::AbstractVector: final solution vector, with same ordering as the Variables specified in nlp.\n\noptimize!(optimizer, nlp::AbstractNLPEvaluator)\n\nWrap previous optimize! function and pass as initial guess x0 the initial value specified when calling initial(nlp).\n\nExamples\n\nnlp = ExaPF.ReducedSpaceEvaluator(datafile)\noptimizer = Ipopt.Optimizer()\nsolution = ExaPF.optimize!(optimizer, nlp)\n\n\nNotes\n\nBy default, the optimization routine solves a minimization problem.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#Attributes","page":"Evaluators","title":"Attributes","text":"","category":"section"},{"location":"lib/evaluators.html","page":"Evaluators","title":"Evaluators","text":"Variables\nConstraints\nn_variables\nn_constraints\nconstraints_type\n","category":"page"},{"location":"lib/evaluators.html#ExaPF.Variables","page":"Evaluators","title":"ExaPF.Variables","text":"Variables <: AbstractNLPAttribute end\n\nAttribute corresponding to the optimization variables attached to a given AbstractNLPEvaluator.\n\n\n\n\n\n","category":"type"},{"location":"lib/evaluators.html#ExaPF.Constraints","page":"Evaluators","title":"ExaPF.Constraints","text":"Constraints <: AbstractNLPAttribute end\n\nAttribute corresponding to the constraints  attached to a given AbstractNLPEvaluator.\n\n\n\n\n\n","category":"type"},{"location":"lib/evaluators.html#ExaPF.n_variables","page":"Evaluators","title":"ExaPF.n_variables","text":"n_variables(nlp::AbstractNLPEvaluator)\n\nGet the number of variables in the problem.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#ExaPF.n_constraints","page":"Evaluators","title":"ExaPF.n_constraints","text":"n_constraints(nlp::AbstractNLPEvaluator)\n\nGet the number of constraints in the problem.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#ExaPF.constraints_type","page":"Evaluators","title":"ExaPF.constraints_type","text":"constraints_type(nlp::AbstractNLPEvaluator)\n\nReturn the type of the non-linear constraints of the evaluator nlp, as a Symbol. Result could be :inequality if problem has only inequality constraints, :equality if problem has only equality constraints, or :mixed if problem has both types of constraints.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#Utilities","page":"Evaluators","title":"Utilities","text":"","category":"section"},{"location":"lib/evaluators.html","page":"Evaluators","title":"Evaluators","text":"reset!\nprimal_infeasibility\nprimal_infeasibility!","category":"page"},{"location":"lib/evaluators.html#ExaPF.reset!","page":"Evaluators","title":"ExaPF.reset!","text":"reset!(nlp::AbstractNLPEvaluator)\n\nReset evaluator nlp to default configuration.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#ExaPF.primal_infeasibility","page":"Evaluators","title":"ExaPF.primal_infeasibility","text":"primal_infeasibility(nlp::AbstractNLPEvaluator, u)\n\nReturn primal infeasibility associated to current model nlp evaluated at variable u.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#ExaPF.primal_infeasibility!","page":"Evaluators","title":"ExaPF.primal_infeasibility!","text":"primal_infeasibility!(nlp::AbstractNLPEvaluator, cons, u)\n\nReturn primal infeasibility associated to current model nlp evaluated at variable u. Modify vector cons inplace.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#Callbacks","page":"Evaluators","title":"Callbacks","text":"","category":"section"},{"location":"lib/evaluators.html#Objective","page":"Evaluators","title":"Objective","text":"","category":"section"},{"location":"lib/evaluators.html","page":"Evaluators","title":"Evaluators","text":"gradient!\nhessprod!\nhessian!\n","category":"page"},{"location":"lib/evaluators.html#ExaPF.gradient!","page":"Evaluators","title":"ExaPF.gradient!","text":"gradient!(nlp::AbstractNLPEvaluator, g, u)\n\nEvaluate the gradient of the objective, at given variable u. Store the result inplace in the vector g.\n\nNote\n\nThe vector g should have the same dimension as u.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#ExaPF.hessprod!","page":"Evaluators","title":"ExaPF.hessprod!","text":"hessprod!(nlp::AbstractNLPEvaluator, hessvec, u, v)\n\nEvaluate the Hessian-vector product ∇²f(u) * v of the objective evaluated at variable u. Store the result inplace, in the vector hessvec.\n\nNote\n\nThe vector hessprod should have the same length as u.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#ExaPF.hessian!","page":"Evaluators","title":"ExaPF.hessian!","text":"hessian!(nlp::AbstractNLPEvaluator, H, u)\n\nEvaluate the Hessian ∇²f(u) of the objective function f(u). Store the result inplace, in the n x n dense matrix H.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#Constraints","page":"Evaluators","title":"Constraints","text":"","category":"section"},{"location":"lib/evaluators.html","page":"Evaluators","title":"Evaluators","text":"constraint!\njacobian_structure!\njacobian!\njprod!\njtprod!\nojtprod!","category":"page"},{"location":"lib/evaluators.html#ExaPF.constraint!","page":"Evaluators","title":"ExaPF.constraint!","text":"constraint!(nlp::AbstractNLPEvaluator, cons, u)\n\nEvaluate the constraints of the problem at given variable u. Store the result inplace, in the vector cons.\n\nNote\n\nThe vector cons should have the same dimension as the result returned by n_constraints(nlp).\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#ExaPF.jacobian_structure!","page":"Evaluators","title":"ExaPF.jacobian_structure!","text":"jacobian_structure!(nlp::AbstractNLPEvaluator, rows, cols)\n\nReturn the sparsity pattern of the Jacobian matrix. Stores the results inplace, in the vectors rows and cols (whose dimension should match the number of non-zero in the Jacobian matrix).\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#ExaPF.jacobian!","page":"Evaluators","title":"ExaPF.jacobian!","text":"jacobian!(nlp::AbstractNLPEvaluator, jac, u)\n\nEvaluate the Jacobian of the constraints, at variable u. Store the result inplace, in the m x n dense matrix jac.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#ExaPF.jprod!","page":"Evaluators","title":"ExaPF.jprod!","text":"jprod!(nlp::AbstractNLPEvaluator, jv, u, v)\n\nEvaluate the Jacobian-vector product J v of the constraints. The vector jv is modified inplace.\n\nLet (n, m) = n_variables(nlp), n_constraints(nlp).\n\nu is a vector with dimension n\nv is a vector with dimension n\njv is a vector with dimension m\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#ExaPF.jtprod!","page":"Evaluators","title":"ExaPF.jtprod!","text":"jtprod!(nlp::AbstractNLPEvaluator, jv, u, v)\n\nEvaluate the transpose Jacobian-vector product J^T v of the constraints. The vector jv is modified inplace.\n\nLet (n, m) = n_variables(nlp), n_constraints(nlp).\n\nu is a vector with dimension n\nv is a vector with dimension m\njv is a vector with dimension n\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#ExaPF.ojtprod!","page":"Evaluators","title":"ExaPF.ojtprod!","text":"ojtprod!(nlp::AbstractNLPEvaluator, jv, u, σ, v)\n\nEvaluate the transpose Jacobian-vector product J' * [σ ; v], with J the Jacobian of the vector [f(x); h(x)]. f(x) is the current objective and h(x) constraints. The vector jv is modified inplace.\n\nLet (n, m) = n_variables(nlp), n_constraints(nlp).\n\njv is a vector with dimension n\nu is a vector with dimension n\nσ is a scalar\nv is a vector with dimension m\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#Second-order","page":"Evaluators","title":"Second-order","text":"","category":"section"},{"location":"lib/evaluators.html","page":"Evaluators","title":"Evaluators","text":"hessian_lagrangian_penalty_prod!\n","category":"page"},{"location":"lib/evaluators.html#ExaPF.hessian_lagrangian_penalty_prod!","page":"Evaluators","title":"ExaPF.hessian_lagrangian_penalty_prod!","text":"hessian_lagrangian_penalty_prod!(nlp::AbstractNLPEvaluator, hessvec, u, y, σ, v, d)\n\nEvaluate the Hessian-vector product of the Lagrangian function L(u y) = f(u) + sum_i y_i c_i(u) + frac12 d_i c_i(u)^2 with a vector v:\n\n²L(u y)  v  = σ ²f(u)  v + sum_i (y_i + d_i) ²c_i(u)  v + sum_i d_i c_i(u)^T c_i(u)\n\nStore the result inplace, in the vector hessvec.\n\nArguments\n\nhessvec is a AbstractVector with dimension n, which is modified inplace.\nu is a AbstractVector with dimension n, storing the current variable.\ny is a AbstractVector with dimension n, storing the current constraints' multipliers\nσ is a scalar\nv is a vector with dimension n.\nd is a vector with dimension m.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#ReducedSpaceEvaluator","page":"Evaluators","title":"ReducedSpaceEvaluator","text":"","category":"section"},{"location":"lib/evaluators.html","page":"Evaluators","title":"Evaluators","text":"When working in the reduced space, we could use the corresponding ReducedSpaceEvaluator:","category":"page"},{"location":"lib/evaluators.html","page":"Evaluators","title":"Evaluators","text":"ReducedSpaceEvaluator","category":"page"},{"location":"lib/evaluators.html#ExaPF.ReducedSpaceEvaluator","page":"Evaluators","title":"ExaPF.ReducedSpaceEvaluator","text":"ReducedSpaceEvaluator{T, VI, VT, MT, Jacx, Jacu, JacCons, Hess} <: AbstractNLPEvaluator\n\nReduced-space evaluator projecting the optimization problem into the powerflow manifold defined by the nonlinear equation g(x u) = 0. The state x is defined implicitly, as a function of the control u. Hence, the powerflow equation is implicitly satisfied when we are using this evaluator.\n\nOnce a new point u is passed to the evaluator, the user needs to call the method update! to find the corresponding state x(u) satisfying the balance equation g(x(u) u) = 0.\n\nTaking as input a PolarForm structure, the reduced evaluator builds the bounds corresponding to the control u, The reduced evaluator could be instantiated on the host memory, or on a specific device (currently, only CUDA is supported).\n\nExamples\n\njulia> datafile = \"case9.m\"  # specify a path to a MATPOWER instance\njulia> nlp = ReducedSpaceEvaluator(datafile)\nA ReducedSpaceEvaluator object\n    * device: KernelAbstractions.CPU()\n    * #vars: 5\n    * #cons: 10\n    * constraints:\n        - voltage_magnitude_constraints\n        - active_power_constraints\n        - reactive_power_constraints\n    * linear solver: ExaPF.LinearSolvers.DirectSolver()\n\nIf a GPU is available, we could instantiate nlp as\n\njulia> nlp_gpu = ReducedSpaceEvaluator(datafile; device=CUDADevice())\nA ReducedSpaceEvaluator object\n    * device: KernelAbstractions.CUDADevice()\n    * #vars: 5\n    * #cons: 10\n    * constraints:\n        - voltage_magnitude_constraints\n        - active_power_constraints\n        - reactive_power_constraints\n    * linear solver: ExaPF.LinearSolvers.DirectSolver()\n\n\nNote\n\nMathematically, we set apart the state x from the control u, and use a third variable y –- the by-product –- to denote the remaining values of the network. In the implementation of ReducedSpaceEvaluator, we only deal with a control u and an attribute buffer, storing all the physical values needed to describe the network. The attribute buffer stores the values of the control u, the state x and the by-product y. Each time we are calling the method update!, the values of the control are copied into the buffer.\n\n\n\n\n\n","category":"type"},{"location":"lib/evaluators.html#SlackEvaluator","page":"Evaluators","title":"SlackEvaluator","text":"","category":"section"},{"location":"lib/evaluators.html","page":"Evaluators","title":"Evaluators","text":"SlackEvaluator","category":"page"},{"location":"lib/evaluators.html#ExaPF.SlackEvaluator","page":"Evaluators","title":"ExaPF.SlackEvaluator","text":"SlackEvaluator{Evaluator<:AbstractNLPEvaluator, T, VT} <: AbstractNLPEvaluator\n\nReformulate a problem with inequality constraints as an equality constrained problem, by introducing a set of slack variables.\n\nDescription\n\nA SlackEvaluator takes as input an original AbstractNLPEvaluator, subject to inequality constraints\n\nbeginaligned\n       min_u in mathbbR^n quad  f(u)\nmathrmst quad  h^  h(u)  h^\n                     u^   u    u^\nendaligned\n\nThe SlackEvaluator instance rewrites this problem with inequalities as a new problem comprising only equality constraints, by introducing m slack variables s_1  s_m. The new problem writes out\n\nbeginaligned\n       min_u in mathbbR^n s in mathbbR^m quad  f(u)\n    mathrmst quad  h(u) - s = 0 \n                     u^   u    u^ \n                     h^   s    h^\nendaligned\n\nAttributes\n\ninner::Evaluator: original evaluator\ns_min::VT: stores lower bounds for slack variables\ns_max::VT: stores upper bounds for slack variables\nnv::Int: number of original variables\nns::Int: number of slack variables\n\n\n\n\n\n","category":"type"},{"location":"lib/evaluators.html#AugLagEvaluator","page":"Evaluators","title":"AugLagEvaluator","text":"","category":"section"},{"location":"lib/evaluators.html","page":"Evaluators","title":"Evaluators","text":"AugLagEvaluator","category":"page"},{"location":"lib/evaluators.html#ExaPF.AugLagEvaluator","page":"Evaluators","title":"ExaPF.AugLagEvaluator","text":"AugLagEvaluator{Evaluator<:AbstractNLPEvaluator, T, VT} <: AbstractPenaltyEvaluator\n\nAugmented-Lagrangian evaluator.\n\nDescription\n\nTakes as input any AbstractNLPEvaluator encoding a non-linear problem\n\nbeginaligned\n       min_u quad  f(u)\nmathrmst quad  h^  h(u)  h^\n                     u^   u    u^\nendaligned\n\nand return a new evaluator reformulating the original problem by moving the m constraints h^  h(u)  h^ into the objective using a set of penalties ϕ_1  ϕ_m and multiplier estimates λ_1  λ_m:\n\nbeginaligned\n    min_u quad  f(u) + sum_i=1^m ϕ_i(h_i λ_i)   \nmathrmst quad   u^   u     u^\nendaligned\n\nThis evaluator considers explicitly the inequality constraints, without reformulating them by introducing slack variables. Each penalty ϕ_i is defined as\n\nϕ_i(h_i λ_i) = λ_i^ φ_i(h_i) + frac rho2  φ_i(h_i) _2^2\n\nwith φ_i a function to compute the current infeasibility\n\nφ_i(h_i λ_i) = max0  λ_i + ρ (h_i - h_i^)    + min0  λ_i + ρ (h_i - h_i^)   \n\nAttributes\n\ninner::Evaluator: original problem.\ncons_type: type of the constraints of the original problem (equalities or inequalities).\ncons::VT: a buffer storing the current evaluation of the constraints for the inner evaluator.\nrho::T: current penalty.\nλ::VT: current multiplier.\nscaler::MaxScaler{T,VT}: a scaler to rescale the range of the constraints in the original problem.\n\n\n\n\n\n","category":"type"},{"location":"lib/evaluators.html#MOIEvaluator","page":"Evaluators","title":"MOIEvaluator","text":"","category":"section"},{"location":"lib/evaluators.html","page":"Evaluators","title":"Evaluators","text":"The bridge to MathOptInterface is encoded by the MOIEvaluator structure:","category":"page"},{"location":"lib/evaluators.html","page":"Evaluators","title":"Evaluators","text":"MOIEvaluator","category":"page"},{"location":"lib/evaluators.html#ExaPF.MOIEvaluator","page":"Evaluators","title":"ExaPF.MOIEvaluator","text":"MOIEvaluator <: MOI.AbstractNLPEvaluator\n\nBridge from a ExaPF.AbstractNLPEvaluator to a MOI.AbstractNLPEvaluator.\n\nAttributes\n\nnlp::AbstractNLPEvaluator: the underlying ExaPF problem.\nhash_x::UInt: hash of the last evaluated variable x\nhas_hess::Bool (default: false): if true, pass a Hessian structure to MOI.\n\n\n\n\n\n","category":"type"},{"location":"lib/evaluators.html#ProxALEvaluator","page":"Evaluators","title":"ProxALEvaluator","text":"","category":"section"},{"location":"lib/evaluators.html","page":"Evaluators","title":"Evaluators","text":"ProxALEvaluator","category":"page"},{"location":"lib/evaluators.html#ExaPF.ProxALEvaluator","page":"Evaluators","title":"ExaPF.ProxALEvaluator","text":"ProxALEvaluator{T, VI, VT, MT} <: AbstractNLPEvaluator\n\nEvaluator wrapping a ReducedSpaceEvaluator for use inside the decomposition algorithm implemented in ProxAL.jl.\n\n\n\n\n\n","category":"type"}]
}
