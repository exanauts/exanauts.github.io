var documenterSearchIndex = {"docs":
[{"location":"lib/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"CurrentModule = ExaPF.LinearSolvers","category":"page"},{"location":"lib/linearsolver.html#Linear-solvers","page":"Linear Solver","title":"Linear solvers","text":"","category":"section"},{"location":"lib/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"ExaPF allows to solve linear systems with either direct and indirect linear algebra.","category":"page"},{"location":"lib/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"ldiv!\r\nDirectSolver\r\nKrylovBICGSTAB\r\nBICGSTAB\r\nEigenBICGSTAB\r\n","category":"page"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.ldiv!","page":"Linear Solver","title":"ExaPF.LinearSolvers.ldiv!","text":"ldiv!(solver, y, J, x)\n\nsolver::AbstractLinearSolver: linear solver to solve the system\ny::AbstractVector: Solution\nJ::AbstractMatrix: Input matrix\nx::AbstractVector: RHS\n\nSolve the linear system `J * y = Fx\n\n\n\n\n\n","category":"function"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.DirectSolver","page":"Linear Solver","title":"ExaPF.LinearSolvers.DirectSolver","text":"DirectSolver <: AbstractLinearSolver\n\nSolve linear system A * x = y with direct linear algebra.\n\nOn the CPU, DirectSolver uses UMFPACK to solve the linear system\nOn CUDA GPU, DirectSolver redirects the resolution to the method CUSOLVER.csrlsvqr\n\n\n\n\n\n","category":"type"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.KrylovBICGSTAB","page":"Linear Solver","title":"ExaPF.LinearSolvers.KrylovBICGSTAB","text":"KrylovBICGSTAB <: AbstractIterativeLinearSolver\nKrylovBICGSTAB(precond; verbose=false, rtol=1e-10, atol=1e-10)\n\nWrap Krylov.jl BICGSTAB algorithm to solve iteratively the linear system A * x = y.\n\n\n\n\n\n","category":"type"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.BICGSTAB","page":"Linear Solver","title":"ExaPF.LinearSolvers.BICGSTAB","text":"BICGSTAB <: AbstractIterativeLinearSolver\nBICGSTAB(precond; maxiter=2_000, tol=1e-8, verbose=false)\n\nCustom BICGSTAB implementation to solve iteratively the linear system A * x = y.\n\n\n\n\n\n","category":"type"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.EigenBICGSTAB","page":"Linear Solver","title":"ExaPF.LinearSolvers.EigenBICGSTAB","text":"EigenBICGSTAB <: AbstractIterativeLinearSolver\nEigenBICGSTAB(precond; maxiter=2_000, tol=1e-8, verbose=false)\n\nJulia's port of Eigen's BICGSTAB to solve iteratively the linear system A * x = y.\n\n\n\n\n\n","category":"type"},{"location":"lib/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"Available linear solvers could be queried with","category":"page"},{"location":"lib/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"list_solvers\r\n","category":"page"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.list_solvers","page":"Linear Solver","title":"ExaPF.LinearSolvers.list_solvers","text":"list_solvers(::KernelAbstractions.Device)\n\nList linear solvers available on current device. Currently, only CPU() and CUDADevice() are supported.\n\n\n\n\n\n","category":"function"},{"location":"lib/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"ExaPF.jl is shipped with a custom BICGSTAB implementation. However, we highly recommend to use KrylovBICGSTAB instead, which has proved to be more robust.","category":"page"},{"location":"lib/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"bicgstab\r\n","category":"page"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.bicgstab","page":"Linear Solver","title":"ExaPF.LinearSolvers.bicgstab","text":"bicgstab(A, b, P, xi;\n         tol=1e-8,\n         maxiter=size(A, 1),\n         verbose=false,\n         maxtol=1e20)\n\nBiCGSTAB implementation according to\n\nVan der Vorst, Henk A. \"Bi-CGSTAB: A fast and smoothly converging variant of Bi-CG for the solution of nonsymmetric linear systems.\" SIAM Journal on scientific and Statistical Computing 13, no. 2 (1992): 631-644.\n\n\n\n\n\n","category":"function"},{"location":"lib/linearsolver.html#Preconditioning","page":"Linear Solver","title":"Preconditioning","text":"","category":"section"},{"location":"lib/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"To solve linear systems with iterative methods, ExaPF provides an implementation of a block-Jacobi preconditioner, portable on GPU.","category":"page"},{"location":"lib/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"AbstractPreconditioner","category":"page"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.AbstractPreconditioner","page":"Linear Solver","title":"ExaPF.LinearSolvers.AbstractPreconditioner","text":"AbstractPreconditioner\n\nPreconditioners for the iterative solvers mostly focused on GPUs\n\n\n\n\n\n","category":"type"},{"location":"lib/linearsolver.html#Block-Jacobi-preconditioner","page":"Linear Solver","title":"Block-Jacobi preconditioner","text":"","category":"section"},{"location":"lib/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"BlockJacobiPreconditioner\r\nupdate\r\nbuild_adjmatrix\r\nfillblock_gpu!\r\nfillP_gpu!","category":"page"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.BlockJacobiPreconditioner","page":"Linear Solver","title":"ExaPF.LinearSolvers.BlockJacobiPreconditioner","text":"BlockJacobiPreconditioner\n\nCreates an object for the block-Jacobi preconditioner\n\nnpart::Int64: Number of partitions or blocks\nnJs::Int64: Size of the blocks. For the GPUs these all have to be of equal size.\npartitions::Vector{Vector{Int64}}:npart` partitions stored as lists\ncupartitions: partitions transfered to the GPU\nJs: Dense blocks of the block-Jacobi\ncuJs: Js transfered to the GPU\nmap: The partitions as a mapping to construct views\ncumap: cumap transferred to the GPU`\npart: Partitioning as output by Metis\ncupart: part transferred to the GPU\nP: The sparse precondition matrix whose values are updated at each iteration\n\n\n\n\n\n","category":"type"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.update","page":"Linear Solver","title":"ExaPF.LinearSolvers.update","text":"function update(J::CuSparseMatrixCSR, p)\n\nUpdate the preconditioner p from the sparse Jacobian J in CSR format for the GPU\n\nThe dense blocks cuJs are filled from the sparse Jacobian J\nTo a batch inversion of the dense blocks using CUBLAS\nExtract the preconditioner matrix p.P from the dense blocks cuJs\n\n\n\n\n\nfunction update(J::SparseMatrixCSC, p)\n\nUpdate the preconditioner p from the sparse Jacobian J in CSC format for the CPU\n\nNote that this implements the same algorithm as for the GPU and becomes very slow on CPU with growing number of blocks.\n\n\n\n\n\n","category":"function"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.build_adjmatrix","page":"Linear Solver","title":"ExaPF.LinearSolvers.build_adjmatrix","text":"build_adjmatrix\n\nBuild the adjacency matrix of a matrix A corresponding to the undirected graph\n\n\n\n\n\n","category":"function"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.fillblock_gpu!","page":"Linear Solver","title":"ExaPF.LinearSolvers.fillblock_gpu!","text":"fillblock_gpu\n\nFill the dense blocks of the preconditioner from the sparse CSC matrix arrays\n\n\n\n\n\n","category":"function"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.fillP_gpu!","page":"Linear Solver","title":"ExaPF.LinearSolvers.fillP_gpu!","text":"fillblock_gpu\n\nUpdate the values of the preconditioner matrix from the dense Jacobi blocks\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"CurrentModule = ExaPF","category":"page"},{"location":"lib/formulations.html#Formulations","page":"Formulations","title":"Formulations","text":"","category":"section"},{"location":"lib/formulations.html#Description","page":"Formulations","title":"Description","text":"","category":"section"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"AbstractFormulation\r\n","category":"page"},{"location":"lib/formulations.html#ExaPF.AbstractFormulation","page":"Formulations","title":"ExaPF.AbstractFormulation","text":"AbstractFormulation\n\nSecond layer of the package, implementing the interface between the first layer (the topology of the network) and the third layer (implementing the callbacks for the optimization solver).\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#API-Reference","page":"Formulations","title":"API Reference","text":"","category":"section"},{"location":"lib/formulations.html#Variables","page":"Formulations","title":"Variables","text":"","category":"section"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"AbstractVariable\r\nState\r\nControl\r\nParameters\r\nPhysicalState\r\n","category":"page"},{"location":"lib/formulations.html#ExaPF.AbstractVariable","page":"Formulations","title":"ExaPF.AbstractVariable","text":"AbstractVariable\n\nVariables corresponding to a particular formulation.\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#ExaPF.State","page":"Formulations","title":"ExaPF.State","text":"State <: AbstractVariable\n\nAll variables x depending on the variables Control u through a non-linear equation g(x, u) = 0.\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#ExaPF.Control","page":"Formulations","title":"ExaPF.Control","text":"Control <: AbstractVariable\n\nImplement the independent variables used in the reduced-space formulation.\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#ExaPF.Parameters","page":"Formulations","title":"ExaPF.Parameters","text":"Parameters <: AbstractVariable\n\nConstant parameters.\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#ExaPF.PhysicalState","page":"Formulations","title":"ExaPF.PhysicalState","text":"PhysicalState <: AbstractVariable\n\nAll physical variables describing the current physical state of the underlying network.\n\nPhysicalState variables are encoded in a AbstractNetworkBuffer, storing all the physical values needed to describe the current state of the network.\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"Get default values attached to a given variable:","category":"page"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"initial\r\n","category":"page"},{"location":"lib/formulations.html#ExaPF.initial","page":"Formulations","title":"ExaPF.initial","text":"initial(form::AbstractFormulation, var::AbstractVariable)\n\nReturn an initial position for the variable var.\n\nExamples\n\nu₀ = initial(form, Control())\nx₀ = initial(form, State())\n\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#Attributes","page":"Formulations","title":"Attributes","text":"","category":"section"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"AbstractFormAttribute\r\nNumberOfState\r\nNumberOfControl\r\n","category":"page"},{"location":"lib/formulations.html#ExaPF.AbstractFormAttribute","page":"Formulations","title":"ExaPF.AbstractFormAttribute","text":"AbstractFormAttribute\n\nAttributes attached to an AbstractFormulation.\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#ExaPF.NumberOfState","page":"Formulations","title":"ExaPF.NumberOfState","text":"Number of states attached to a particular formulation.\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#ExaPF.NumberOfControl","page":"Formulations","title":"ExaPF.NumberOfControl","text":"Number of controls attached to a particular formulation.\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"ExaPF extends Base.get to query the different attributes of a model:","category":"page"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"get\r\n","category":"page"},{"location":"lib/formulations.html#Base.get","page":"Formulations","title":"Base.get","text":"get(form::AbstractFormulation, attr::AbstractFormAttribute)\n\nReturn value of attribute attr attached to the particular formulation form.\n\nExamples\n\nget(form, NumberOfState())\nget(form, NumberOfControl())\n\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#Powerflow-solver","page":"Formulations","title":"Powerflow solver","text":"","category":"section"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"powerflow\r\npower_balance!\r\n","category":"page"},{"location":"lib/formulations.html#ExaPF.powerflow","page":"Formulations","title":"ExaPF.powerflow","text":"powerflow(form::AbstractFormulation,\n          jacobian::AutoDiff.StateJacobian,\n          buffer::AbstractNetworkBuffer;\n          kwargs...) where VT <: AbstractVector\n\nSolve the power flow equations g(x, u) = 0 w.r.t. the state x, using a Newton-Raphson algorithm. The powerflow equations are specified in the formulation form. The current state x and control u are specified in buffer. The object buffer is modified inplace.\n\nThe algorithm stops when a tolerance tol or a maximum number of irations maxiter are reached.\n\nArguments\n\nform::AbstractFormulation: formulation of the power flow equation\njacobian::AutoDiff.StateJacobian: Jacobian\nbuffer::AbstractNetworkBuffer: buffer storing current state x and control u\n\nOptional arguments\n\nlinear_solver::AbstractLinearSolver (default DirectSolver()): solver to solve the linear systems J x = y arising at each iteration of the Newton-Raphson algorithm.\ntol::Float64 (default 1e-7): tolerance of the Newton-Raphson algorithm.\nmaxiter::Int (default 20): maximum number of iterations.\nverbose_level::Int (default O, max value: 3): verbose level.\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#ExaPF.power_balance!","page":"Formulations","title":"ExaPF.power_balance!","text":"power_balance!(form::AbstractFormulation, x::VT, u::VT, p::VT) where {VT<:AbstractVector}\n\nGet power balance at buses, depending on the state x and the control u.\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#Costs","page":"Formulations","title":"Costs","text":"","category":"section"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"cost_production","category":"page"},{"location":"lib/formulations.html#ExaPF.cost_production","page":"Formulations","title":"ExaPF.cost_production","text":"cost_production(form::AbstractFormulation, pg::AbstractVector)::Float64\n\nGet operational cost corresponding to the active power generation specified in the vector pg.\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#Constraints","page":"Formulations","title":"Constraints","text":"","category":"section"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"Current supported constraints are:","category":"page"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"state_constraints\r\npower_constraints\r\nthermal_limit_constraints\r\n","category":"page"},{"location":"lib/formulations.html#ExaPF.state_constraints","page":"Formulations","title":"ExaPF.state_constraints","text":"state_constraints(form::AbstractFormulation, cons::AbstractVector, buffer::AbstractNetworkBuffer)\n\nEvaluate the constraints porting on the state x, as a function of x and u. The result is stored inplace, inside g.\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#ExaPF.power_constraints","page":"Formulations","title":"ExaPF.power_constraints","text":"power_constraints(form::AbstractFormulation, cons::AbstractVector, buffer::AbstractNetworkBuffer) where {VT<:AbstractVector}\n\nEvaluate the constraints on the power production that are not taken into account in\n\nthe box constraints on the control u\nthe box constraints on the state x (implemented in state_constraints)\n\nThe result is stored inplace, inside g.\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#ExaPF.thermal_limit_constraints","page":"Formulations","title":"ExaPF.thermal_limit_constraints","text":"thermal_limit_constraints(form::AbstractFormulation, cons::AbstractVector, buffer::AbstractNetworkBuffer) where {VT<:AbstractVector}\n\nEvaluate the thermal limit constraints porting on the lines of the network.\n\nThe result is stored inplace, inside the vector g.\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"These functions allow to query constraints' attributes:","category":"page"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"is_constraint\r\nsize_constraint\r\nbounds\r\n","category":"page"},{"location":"lib/formulations.html#ExaPF.is_constraint","page":"Formulations","title":"ExaPF.is_constraint","text":"size_constraint(cons_func::Function)::Bool\n\nReturn whether the function cons_func is a supported constraint in the powerflow model.\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#ExaPF.size_constraint","page":"Formulations","title":"ExaPF.size_constraint","text":"size_constraint(form::AbstractFormulation, cons_func::Function)::Int\n\nGet number of constraints specified by the function cons_func in the formulation form.\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#ExaPF.bounds","page":"Formulations","title":"ExaPF.bounds","text":"bounds(form::AbstractFormulation, var::AbstractVariable)\n\nReturn the bounds attached to the variable var.\n\nbounds(form::AbstractFormulation, func::Function)\n\nReturn a tuple of vectors (lb, ub) specifying the admissible range of the constraints specified by the function cons_func.\n\nExamples\n\nu_min, u_max = bounds(form, Control())\nh_min, h_max = bounds(form, power_constraints)\n\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#Utils","page":"Formulations","title":"Utils","text":"","category":"section"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"To ease the integration, the following functions have been imported from MATPOWER. Note that these functions work exclusively on the CPU.","category":"page"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"power_balance\r\nresidual_jacobian\r\n","category":"page"},{"location":"lib/formulations.html#ExaPF.power_balance","page":"Formulations","title":"ExaPF.power_balance","text":"power_balance(V, Ybus, Sbus, pv, pq)\n\nAssembly residual function for N-R power flow. In complex form, the balance equations writes\n\ng(V) = V * (Y_bus * V)^* - S_bus\n\nNote\n\nCode adapted from MATPOWER.\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#ExaPF.residual_jacobian","page":"Formulations","title":"ExaPF.residual_jacobian","text":"residual_jacobian(V, Ybus, pv, pq)\n\nCompute the Jacobian w.r.t. the state x of the power balance function power_balance.\n\nNote\n\nCode adapted from MATPOWER.\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html","page":"Formulations","title":"Formulations","text":"get_power_injection\r\nget_react_injection","category":"page"},{"location":"lib/formulations.html#ExaPF.get_power_injection","page":"Formulations","title":"ExaPF.get_power_injection","text":"get_power_injection(fr, v_m, v_a, ybus_re, ybus_im)\n\nComputes the power injection at node fr. In polar form, the power injection at node i satisfies\n\np_i = sum_j v_i v_j (g_ij cos(theta_i - theta_j) + b_ij sin(theta_i - theta_j))\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#ExaPF.get_react_injection","page":"Formulations","title":"ExaPF.get_react_injection","text":"get_react_injection(fr, v_m, v_a, ybus_re, ybus_im)\n\nComputes the reactive power injection at node fr. In polar form, the power injection at node i satisfies\n\nq_i = sum_j v_i v_j (g_ij sin(theta_i - theta_j) - b_ij cos(theta_i - theta_j))\n\n\n\n\n\n","category":"function"},{"location":"lib/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"CurrentModule = ExaPF.AutoDiff","category":"page"},{"location":"lib/autodiff.html#Description","page":"AutoDiff","title":"Description","text":"","category":"section"},{"location":"lib/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"AbstractJacobian","category":"page"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.AbstractJacobian","page":"AutoDiff","title":"ExaPF.AutoDiff.AbstractJacobian","text":"AbstractJacobian\n\nAutomatic differentiation for the compressed Jacobians of the constraints g(x,u) with respect to the state x and the control u (here called design).\n\nTODO: Use dispatch to unify the code of the state and control Jacobian. This is currently not done because the abstraction of the indexing is not yet resolved.\n\n\n\n\n\n","category":"type"},{"location":"lib/autodiff.html#API-Reference","page":"AutoDiff","title":"API Reference","text":"","category":"section"},{"location":"lib/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"StateJacobian\r\nControlJacobian\r\nseed_kernel_cpu!\r\nseed_kernel_gpu!\r\nseed_kernel!\r\ngetpartials_kernel_cpu!\r\ngetpartials_kernel_gpu!\r\ngetpartials_kernel!\r\nuncompress_kernel_gpu!\r\nuncompress_kernel!\r\nresidual_jacobian!","category":"page"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.StateJacobian","page":"AutoDiff","title":"ExaPF.AutoDiff.StateJacobian","text":"StateJacobian\n\nCreates an object for the state Jacobian\n\nJ::SMT: Sparse uncompressed Jacobian to be used by linear solver. This is either of type SparseMatrixCSC or CuSparseMatrixCSR.\ncompressedJ::MT: Dense compressed Jacobian used for updating values through AD either of type Matrix or CuMatrix.\ncoloring::VI: Row coloring of the Jacobian.\nt1sseeds::VP: The seeding vector for AD built based on the coloring.\nt1sF::VD: Output array of active (AD) type.\nx::VT: Input array of passive type. This includes both state and control.\nt1sx::VD: Input array of active type.\nmap::VI: State and control mapping to array x\nvarx::SubT: View of map on x\nt1svarx::SubD: Active (AD) view of map on x\n\n\n\n\n\n","category":"type"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.ControlJacobian","page":"AutoDiff","title":"ExaPF.AutoDiff.ControlJacobian","text":"ControlJacobian\n\nCreates an object for the control Jacobian.\n\nJ::SMT: Sparse uncompressed Jacobian to be used by linear solver. This is either of type SparseMatrixCSC or CuSparseMatrixCSR.\ncompressedJ::MT: Dense compressed Jacobian used for updating values through AD either of type Matrix or CuMatrix.\ncoloring::VI: Row coloring of the Jacobian.\nt1sseeds::VP: The seeding vector for AD built based on the coloring.\nt1sF::VD: Output array of active (AD) type.\nx::VT: Input array of passive type. This includes both state and control.\nt1sx::VD: Input array of active type.\nmap::VI: State and control mapping to array x\nvarx::SubT: View of map on x\nt1svarx::SubD: Active (AD) view of map on x\n\n\n\n\n\n","category":"type"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.seed_kernel_cpu!","page":"AutoDiff","title":"ExaPF.AutoDiff.seed_kernel_cpu!","text":"seed_kernel_cpu!\n\nSeeding on the CPU, not parallelized.\n\n\n\n\n\n","category":"function"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.seed_kernel_gpu!","page":"AutoDiff","title":"ExaPF.AutoDiff.seed_kernel_gpu!","text":"seed_kernel_gpu!\n\nSeeding on GPU parallelized over the ncolor number of duals\n\n\n\n\n\n","category":"function"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.seed_kernel!","page":"AutoDiff","title":"ExaPF.AutoDiff.seed_kernel!","text":"seed_kernel!\n\nCalling the GPU seeding kernel\n\n\n\n\n\nseed_kernel!(t1sseeds::Vector{ForwardDiff.Partials{N,V}}, varx, t1svarx, nbus) where {N, V}\n\nCalling the CPU seeding kernel\n\n\n\n\n\n","category":"function"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.getpartials_kernel_cpu!","page":"AutoDiff","title":"ExaPF.AutoDiff.getpartials_kernel_cpu!","text":"getpartials_kernel_cpu!(compressedJ, t1sF)\n\nExtract the partials from the AutoDiff dual type on the CPU and put it in the compressed Jacobian\n\n\n\n\n\n","category":"function"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.getpartials_kernel_gpu!","page":"AutoDiff","title":"ExaPF.AutoDiff.getpartials_kernel_gpu!","text":"getpartials_kernel_gpu!(compressedJ, t1sF)\n\nExtract the partials from the AutoDiff dual type on the GPU and put it in the compressed Jacobian\n\n\n\n\n\n","category":"function"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.getpartials_kernel!","page":"AutoDiff","title":"ExaPF.AutoDiff.getpartials_kernel!","text":"getpartials_kernel!(compressedJ::CuArray{T, 2}, t1sF, nbus) where T\n\nCalling the GPU partial extraction kernel\n\n\n\n\n\ngetpartials_kernel!(compressedJ::Array{T, 2}, t1sF, nbus) where T\n\nCalling the CPU partial extraction kernel\n\n\n\n\n\n","category":"function"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.uncompress_kernel_gpu!","page":"AutoDiff","title":"ExaPF.AutoDiff.uncompress_kernel_gpu!","text":"uncompress_kernel_gpu!(J_nzVal, J_rowPtr, J_colVal, compressedJ, coloring, nmap)\n\nUncompress the compressed Jacobian matrix from compressedJ to sparse CSR on the GPU. Only bitarguments are allowed for the kernel. (for GPU only) TODO: should convert to @kernel\n\n\n\n\n\n","category":"function"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.uncompress_kernel!","page":"AutoDiff","title":"ExaPF.AutoDiff.uncompress_kernel!","text":"uncompress_kernel!(J::SparseArrays.SparseMatrixCSC, compressedJ, coloring)\n\nUncompress the compressed Jacobian matrix from compressedJ to sparse CSC on the CPU.\n\n\n\n\n\nuncompress_kernel!(J::CUDA.CUSPARSE.CuSparseMatrixCSR, compressedJ, coloring)\n\nUncompress the compressed Jacobian matrix from compressedJ to sparse CSC on the GPU by calling the kernel uncompress_kernel_gpu!.\n\n\n\n\n\n","category":"function"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.residual_jacobian!","page":"AutoDiff","title":"ExaPF.AutoDiff.residual_jacobian!","text":"residual_jacobian!(arrays::StateJacobian,\n                    residual_polar!,\n                    v_m, v_a, ybus_re, ybus_im, pinj, qinj, pv, pq, ref, nbus,\n                    timer = nothing)\n\nUpdate the sparse Jacobian entries using AutoDiff. No allocations are taking place in this function.\n\narrays::StateJacobian: Factory created Jacobian object to update\nresidual_polar: Primal function\nv_m, v_a, ybus_re, ybus_im, pinj, qinj, pv, pq, ref, nbus: Inputs both active and passive parameters. Active inputs are mapped to x via the preallocated views.\n\n\n\n\n\nresidual_jacobian!(arrays::ControlJacobian,\n                    residual_polar!,\n                    v_m, v_a, ybus_re, ybus_im, pinj, qinj, pv, pq, ref, nbus,\n                    timer = nothing)\n\nUpdate the sparse Jacobian entries using AutoDiff. No allocations are taking place in this function.\n\narrays::ControlJacobian: Factory created Jacobian object to update\nresidual_polar: Primal function\nv_m, v_a, ybus_re, ybus_im, pinj, qinj, pv, pq, ref, nbus: Inputs both active and passive parameters. Active inputs are mapped to x via the preallocated views.\n\n\n\n\n\n","category":"function"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"CurrentModule = ExaPF\r\nDocTestSetup = quote\r\n    using ExaPF\r\n    const PS = ExaPF.PowerSystem\r\nend\r\nDocTestFilters = [r\"ExaPF\"]","category":"page"},{"location":"man/powersystem.html#PowerSystem","page":"PowerSystem","title":"PowerSystem","text":"","category":"section"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"The main goal of ExaPF.jl is the solution of optimization problems for electrical power systems in the steady state. The first step in this process is the creation of an object that describes the physics and topology of the power system which ultimately will be mapped into an abstract mathematical optimization problem. In this section we briefly review the power system in the steady state and describe the tools to create and examine power systems in ExaPF.jl.","category":"page"},{"location":"man/powersystem.html#Description","page":"PowerSystem","title":"Description","text":"","category":"section"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"The electrical power system is represented as a linear, lumped network which has to satisfy the Kirchhoff laws:","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"    bmi = bmYbmv ","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"where bmi bmv in mathbbC^N_B are the current and voltage vectors associated to the system and bmY in mathbbC^N_B times N_B is the admittance matrix. These equations are often rewritten in terms of apparent powers:","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"    bms = bmp + jbmq = textitdiag(bmv^*) bmYbmv","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"Using polar representation of the voltage vector, such as bmv = ve^j theta, each bus i=1 cdots N_B  must satisfy the power balance equations:","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"beginaligned\r\n    p_i = v_i sum_j^n v_j (g_ijcos(theta_i - theta_j) + b_ijsin(theta_i - theta_j))  \r\n    q_i = v_i sum_j^n v_j (g_ijsin(theta_i - theta_j) - b_ijcos(theta_i - theta_j)) \r\nendaligned","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"where each bus i has variables p_i q_i v_i theta_i and the topology of the network is defined by a non-negative value of the admittance between two buses i and j, y_ij = g_ij + ib_ij.","category":"page"},{"location":"man/powersystem.html#The-PowerNetwork-object","page":"PowerSystem","title":"The PowerNetwork object","text":"","category":"section"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"Currently we can create a PowerNetwork object by parsing a MATPOWER datafile.","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"julia> ps = PowerSystem.PowerNetwork(\"data/case9.m\")","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"Apart of MATPOWER datafile, PSSE datafile are also supported:","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"julia> ps = PowerSystem.PowerNetwork(\"data/case14.raw\")","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"If we print the object, we will obtain bus information and initial voltage and power that we read from the datafile.","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"julia> println(ps)\r\nPower Network characteristics:\r\n    Buses: 9. Slack: 1. PV: 2. PQ: 6\r\n    Generators: 3.\r\n    ==============================================\r\n    BUS      TYPE    VMAG    VANG    P   Q\r\n    ==============================================\r\n    1     3      1.000  0.00    0.000   0.000\r\n    2     2      1.000  0.00    1.630   0.000\r\n    3     2      1.000  0.00    0.850   0.000\r\n    4     1      1.000  0.00    0.000   0.000\r\n    5     1      1.000  0.00    -0.900  -0.300\r\n    6     1      1.000  0.00    0.000   0.000\r\n    7     1      1.000  0.00    -1.000  -0.350\r\n    8     1      1.000  0.00    0.000   0.000\r\n    9     1      1.000  0.00    -1.250  -0.500","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"then, using multiple dispatch, we have defined a set of abstract datatypes and getter functions which allow us to retrieve information from the PowerNetwork object","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"julia> PowerSystem.get(ps, PowerSystem.NumberOfPQBuses())\r\n6\r\njulia> PowerSystem.get(ps, PowerSystem.NumberOfPVBuses())\r\n2\r\njulia> PowerSystem.get(ps, PowerSystem.NumberOfSlackBuses())\r\n1","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"CurrentModule = ExaPF\r\nDocTestSetup = quote\r\n    using ExaPF\r\n    const Precondition = ExaPF.Precondition\r\n    const Iterative = ExaPF.Iterative\r\nend\r\nDocTestFilters = [r\"ExaPF\"]","category":"page"},{"location":"man/linearsolver.html#Linear-Solver","page":"Linear Solver","title":"Linear Solver","text":"","category":"section"},{"location":"man/linearsolver.html#Overview","page":"Linear Solver","title":"Overview","text":"","category":"section"},{"location":"man/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"As mentioned before, a linear solver is required to compute the Newton step in","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"dx .= jacobian(x)\\f(x)","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"Our package supports the following linear solvers:","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"CUSOLVER with csrlsvqr (GPU),\nKrylov.jl with dqgmres and bicgstab (CPU/GPU),\nIterativeSolvers.jl with bicgstab (CPU),\nUMFPACK through the default Julia \\ operator (CPU),\nand a generic BiCGSTAB implementation [Vorst1992] (CPU/GPU).","category":"page"},{"location":"man/linearsolver.html#Preconditioning","page":"Linear Solver","title":"Preconditioning","text":"","category":"section"},{"location":"man/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"Using only an iterative solver leads to divergence and bad performance due to ill-conditioning of the Jacobian. This is a known phenomenon in power systems. That's why this package comes with a block Jacobi preconditioner that is tailored towards GPUs and is proven to work well with power flow problems.","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"The Jacobian is partitioned into a dense block diagonal structure, where each block is inverted to build our preconditioner P. For the partition we use Metis.jl.","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"(Image: Dense block Jacobi preconditioner \\label{fig:preconditioner})","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"Compared to incomplete Cholesky and incomplete LU this preconditioner is easily portable to the GPU if the number of blocks is high enough. ExaPF.jl uses the batch BLAS calls from CUBLAS to invert the single blocks.","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"CUDA.@sync pivot, info = CUDA.CUBLAS.getrf_batched!(blocks, true)\r\nCUDA.@sync pivot, info, p.cuJs = CUDA.CUBLAS.getri_batched(blocks, pivot)","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"Assuming that other vendors will provide such batched BLAS APIs, this code is portable to other GPU architectures.","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solver","title":"Linear Solver","text":"[Vorst1992]: Vorst, H. A. van der. 1992. “Bi-Cgstab: A Fast and Smoothly Converging Variant of Bi-Cg for the Solution of Nonsymmetric Linear Systems.”SIAM Journal on Scientific and Statistical Computing 13 (2): 631–44","category":"page"},{"location":"man/evaluators.html#Evaluators","page":"Evaluators","title":"Evaluators","text":"","category":"section"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"In ExaPF.jl, the evaluators are the final layer of the structure. They take as input a given AbstractFormulation and implement the callbacks for the optimization solvers.","category":"page"},{"location":"man/evaluators.html#Overview","page":"Evaluators","title":"Overview","text":"","category":"section"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"An AbstractEvaluator is tailored to the optimization problem associated with an underlying AbstractFormulation:","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"beginaligned\r\nmin_x u            f(x u)     \r\ntextsubject to quad  g(x u) = 0 \r\n                         h(x u) leq 0\r\nendaligned","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"In this problem, we recognize the state x and the control u introduced earlier. The objective function f(x u), the equality constraints g(x u) = 0 and the inequality constraints h(x u) leq 0 all depend on the state x and the control u. The non-linear functions are all specified inside the AbstractFormulation.","category":"page"},{"location":"man/evaluators.html#Callbacks","page":"Evaluators","title":"Callbacks","text":"","category":"section"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"Most non-linear optimization algorithms rely on callbacks to pass information about the structure of the problem to the optimizer. The evaluator allows to have a proper splitting between the model (formulated in the AbstractFormulation layer) and the optimization algorithms. By design, the implementation of an AbstractEvaluator is similar in spirit than the implementations introduced in other packages, as","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"MathOptInterface.jl's AbstractNLPEvaluator\nNLPModels' AbstractNLPModel","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"The evaluator caches internally all the information needed to evaluate the callbacks. Once a new point u passed to the evaluator, a function update! is being called to update all the internal structures, according to the model specified in the underlying AbstractFormulation. Also, this cache allows to reduce the number of memory allocations to its minimum. In a sense, the evaluator is equivalent to Julia's closures, but tailored to ExaPF.jl usage.","category":"page"},{"location":"man/evaluators.html#A-journey-in-the-reduced-space","page":"Evaluators","title":"A journey in the reduced space","text":"","category":"section"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"When we aim at optimizing the problem directly in the reduced space manifold, the ReducedSpaceNLPEvaluator is our workhorse. We recall that the reduced space is defined implicitly by the powerflow equations:","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"    g(x(u) u) = 0","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"By design, the ReducedSpaceNLPEvaluator works in the powerflow manifold (x(u) u). Hence, the reduced optimization problem writes out","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"beginaligned\r\nmin_u            f(x(u) u)     \r\ntextsubject to quad  h(x(u) u) leq 0\r\nendaligned","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"This formulation comes with two advantages:","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"if the dimension of the state is large, the reduced problem has a lower dimension rendering it more amenable for the optimization algorithm.\nthe powerflow equality constraints g(x u) = 0 disappear in the reduced problem.","category":"page"},{"location":"man/evaluators.html#Playing-with-the-ReducedSpaceNLPEvaluator","page":"Evaluators","title":"Playing with the ReducedSpaceNLPEvaluator","text":"","category":"section"},{"location":"man/evaluators.html#Constructor","page":"Evaluators","title":"Constructor","text":"","category":"section"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"To create a ReducedSpaceNLPEvaluator, we need a given formulation form::AbstractFormulation, together with an initial control u0, an initial state x0 and a vector of parameters p:","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"julia> nlp = ExaPF.ReducedSpaceEvaluator(polar, x0, u0, p)\r\n","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"or we could alternatively instantiate the evaluator directly from a MATPOWER (or PSSE) instance:","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"julia> datafile = \"case9.m\"\r\njulia> nlp = ExaPF.ReducedSpaceEvaluator(datafile)\r\nA ReducedSpaceEvaluator object\r\n    * device: KernelAbstractions.CPU()\r\n    * #vars: 5\r\n    * #cons: 10\r\n    * constraints:\r\n        - state_constraint\r\n        - power_constraints\r\n    * linear solver: ExaPF.LinearSolvers.DirectSolver()\r\n","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"Let's describe the output of the last command.","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"device: KernelAbstractions.CPU(): the evaluator is instantiated on the CPU ;\n#vars: 5: it has 5 optimization variables ;\n#cons: 10: the problem has 10 inequality constraints ;\nconstraints: by default, nlp has two inequality constraints: state_constraint (specifying the bounds x_L leq x(u) leq x_U on the state x) and power_constraints (bounding the active and reactive power of the generators) ;\nlinear solver: ExaPF.LinearSolvers.DirectSolver(): to solve the linear systems, the evaluator uses a direct linear algebra solver.","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"Of course, these settings are only specified by default, and the user is free to choose the parameters she wants. For instance,","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"we could remove all constraints by passing an empty array of constraints to the evaluator:\njulia> constraints = Function[]\r\njulia> nlp = ExaPF.ReducedSpaceEvaluator(datafile; constraints=constraints)\nwe could load the evaluator on the GPU simply by changing the device:\njulia> nlp = ExaPF.ReducedSpaceEvaluator(datafile; device=CUDADevice())","category":"page"},{"location":"man/evaluators.html#Caching","page":"Evaluators","title":"Caching","text":"","category":"section"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"To juggle between the mathematical description (characterized by a state x and a control u) and the physical description (characterized by the voltage and power injection at each bus), the evaluator nlp stores internally a cache nlp.buffer, with type AbstractNetworkBuffer.","category":"page"},{"location":"man/evaluators.html#Evaluation-of-the-callbacks","page":"Evaluators","title":"Evaluation of the callbacks","text":"","category":"section"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"Now that we have a nlp evaluator available, we could embed it in any optimization routine. For instance, suppose we have a new control uk available. First, we need to find the corresponding state xk in the powerflow manifold. In the evaluator's API, this sums up to:","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"ExaPF.update!(nlp, uk)","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"The function update! will","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"Feed the physical description nlp.buffer with the values stored in the new control uk.\nSolve the powerflow equations corresponding to the formulation specified in form. This operation updates the cache nlp.buffer inplace.\nUpdate internally the state x.","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"Once the function update! called (and only once), we could evaluate all the different callbacks independently from one other.","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"Objective\njulia> cost = ExaPF.objective(nlp, uk)\nObjective's gradient\njulia> g = zeros(n_variables(nlp))\r\njulia> ExaPF.gradient!(nlp, g, uk)\nConstraints\n# Evaluate constraints\r\njulia> cons = zeros(n_constraints(nlp))\r\njulia> ExaPF.constraint!(nlp, cons, uk)\nConstraints' Jacobian\n## Evaluate Jacobian\r\njulia> ExaPF.jacobian!(nlp, jac, uk)\nConstraints' transpose Jacobian-vector product\n## Evaluate transpose Jacobian-vector product\r\njulia> v = zeros(n_constraints(nlp))\r\njulia> jv = zeros(n_variables(nlp))\r\njulia> ExaPF.jtprod!(nlp, jv, uk, v)","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"note: Note\nOnce the powerflow equations solved in a update! call, the solution x is stored in memory in the attribute nlp.x. The state x will be used as a starting point for the next resolution of powerflow equations.","category":"page"},{"location":"man/evaluators.html#Passing-the-problem-to-an-optimization-solver-with-MathOptInterface","page":"Evaluators","title":"Passing the problem to an optimization solver with MathOptInterface","text":"","category":"section"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"ExaPF.jl provides a utility to pass the non-linear structure specified by a AbstractNLPEvaluator to a MathOptInterface (MOI) optimization problem. That allows to solve the corresponding optimal power flow problem using any non-linear optimization solver compatible with MOI.","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"For instance, we could solve the reduced problem specified in nlp with Ipopt in a few lines of code:","category":"page"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"using Ipopt\r\noptimizer = Ipopt.Optimizer()\r\n\r\nblock_data = MOI.NLPBlockData(nlp)\r\n\r\nu♭, u♯ = ExaPF.bounds(nlp, ExaPF.Variables())\r\nu0 = ExaPF.initial(nlp)\r\nn = ExaPF.n_variables(nlp)\r\nvars = MOI.add_variables(optimizer, n)\r\n\r\n# Set bounds and initial values\r\nfor i in 1:n\r\n    MOI.add_constraint(\r\n        optimizer,\r\n        MOI.SingleVariable(vars[i]),\r\n        MOI.LessThan(u♯[i])\r\n    )\r\n    MOI.add_constraint(\r\n        optimizer,\r\n        MOI.SingleVariable(vars[i]),\r\n        MOI.GreaterThan(u♭[i])\r\n    )\r\n    MOI.set(optimizer, MOI.VariablePrimalStart(), vars[i], u0[i])\r\nend\r\n\r\nMOI.set(optimizer, MOI.NLPBlock(), block_data)\r\nMOI.set(optimizer, MOI.ObjectiveSense(), MOI.MIN_SENSE)\r\nMOI.optimize!(optimizer)\r\n\r\nsolution = (\r\n    minimum=MOI.get(optimizer, MOI.ObjectiveValue()),\r\n    minimizer=[MOI.get(optimizer, MOI.VariablePrimal(), v) for v in vars],\r\n)\r\nMOI.empty!(optimizer)","category":"page"},{"location":"man/evaluators.html#Going-back-to-the-full-space","page":"Evaluators","title":"Going back to the full space","text":"","category":"section"},{"location":"man/evaluators.html","page":"Evaluators","title":"Evaluators","text":"In the long term, we are planning to implement a FullSpaceNLPEvaluator as well.","category":"page"},{"location":"man/formulations.html#Formulations","page":"Formulations","title":"Formulations","text":"","category":"section"},{"location":"man/formulations.html#Overview","page":"Formulations","title":"Overview","text":"","category":"section"},{"location":"quickstart.html#Quick-Start","page":"Quick start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"This page introduces the first steps to set up ExaPF.jl. We show how to load a power network instance and how to solve the power flow equations both on the CPU and on the GPU.","category":"page"},{"location":"quickstart.html#How-to-load-a-MATPOWER-instance?","page":"Quick start","title":"How to load a MATPOWER instance?","text":"","category":"section"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"We start by importing into ExaPF an instance specified in the MATPOWER format.","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"First, you could load the package with","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"julia> using ExaPF\r\njulia> const PS = ExaPF.PowerSystem","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Imagine you want to load an instance from the pglib-opf benchmark, stored in the current folder:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"julia> pglib_instance = \"pglib_opf_case1354_pegase.m\"","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"ExaPF.jl allows you to load directly the instance as a PowerNetwork object:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"julia> pf = PS.PowerNetwork(pglib_instance)","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"The different fields of the object pf specify the characteristics of the network. For instance, we could retrieve the number of buses or get the indexing of the PV buses with","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"julia> nbus = pf.nbus\r\n1354\r\njulia> pv_indexes = PS.get(pf, PS.PVIndexes())\r\n[17, 21, ..., 1344]","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"However, a PowerNetwork object stores only the physical attributes of the network, independently from the mathematical formulations we could use to model the network. To choose a particular formulation, we need to pass the object pf to a AbstractFormulation layer. Currently, the only layer implemented is the polar formulation, with the PolarForm abstraction. In the future, other formulations (e.g. RectangularForm) may be implemented as well.","category":"page"},{"location":"quickstart.html#How-to-solve-the-powerflow-equations?","page":"Quick start","title":"How to solve the powerflow equations?","text":"","category":"section"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"To solve the powerflow equations, we need to choose a given mathematical formulation for the equations of the network. To each formulation corresponds a given state x and control u. The powerflow equations write in the abstract mathematical formalism:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"g(x u) = 0","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"For a given control u, solving the powerflow equations resumes to find a state x(u) such that g(x(u) u) = 0. To this goal, ExaPF.jl implements a Newton-Raphson algorithm.","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"We first instantiate a PolarForm object to adopt a polar formulation as a model:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"julia> polar = PolarForm(pf, CPU())\r\n","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Note that the constructor PolarForm takes as input a PowerNetwork object and a KernelAbstractions.jl device (here set to CPU() by default). We will explain in the next section how to load a PolarForm object on the GPU with the help of a CUDADevice.","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"The Newton-Raphson solves the equation g(x u) = 0 in an iterative fashion. The algorithm solves at each step the linear equation:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"    x_k+1 = - (nabla_x g_k)^-1 g(x_k u)","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Hence, the algorithm requires the following elements:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"an initial position x_0\na function to evaluate the Jacobian nabla_x g_k\na function to solve efficiently the linear system (nabla_x g_k) x_k+1 = g(x_k u)","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"that translate to the Julia code:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"julia> physical_state = get(polar, PhysicalState())\r\njulia> jx = ExaPF.init_ad_factory(polar, physical_state)\r\njulia> linear_solver = DirectSolver()\r\n","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Let's explain further these three objects.","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"physical_state is a AbstractPhysicalCache storing all the physical values attached to the formulation polar::PolarForm.\njx is a StateJacobianAD which allows the solver to compute efficiently by automatic differentiation the Jacobian of the powerflow equations nabla_x g.\nlinear_solver specifies the linear algorithm uses to solve the linear system (nabla_x g_k) x_k+1 = g(x_k u). By default, we use direct linear algebra.","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Then, we could solve the powerflow equations simply with","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"julia> convergence = ExaPF.powerflow(polar, jx, physical_state,\r\n                                     linear_solver=linear_solver,\r\n                                     verbose_level=1)\r\nIteration 0. Residual norm: 26.6667.\r\nIteration 1. Residual norm: 15.0321.\r\nIteration 2. Residual norm: 0.588264.\r\nIteration 3. Residual norm: 0.00488507.\r\nIteration 4. Residual norm: 1.39924e-06.\r\nIteration 5. Residual norm: 7.37136e-12.","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Here, the algorithm solves the powerflow equations in 5 iterations. The algorithm modifies the values of physical_state inplace, to avoid any unnecessary memory allocations.","category":"page"},{"location":"quickstart.html#How-to-deport-the-computation-on-the-GPU?","page":"Quick start","title":"How to deport the computation on the GPU?","text":"","category":"section"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Now, what if we want to deport the resolution on the GPU? The procedure looks exactly the same. It suffices to initiate a new PolarForm object, but on the GPU:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"julia> polar_gpu = PolarForm(pf, CUDADevice())\r\n","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"polar_gpu will load all the structure it needs on the GPU, to avoid unnecessary movements between the host and the GPU. We could load the other structures directly on the GPU with:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"julia> physical_state_gpu = get(polar, PhysicalState())\r\njulia> jx_gpu = ExaPF.init_ad_factory(polar, physical_state)\r\njulia> linear_solver = DirectSolver()\r\n","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"and then, solving the powerflow equations on the GPU is straightforward:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"julia> convergence = ExaPF.powerflow(polar_gpu, jx_gpu, physical_state_gpu,\r\n                                     linear_solver=linear_solver,\r\n                                     verbose_level=1)\r\nIteration 0. Residual norm: 26.6667.\r\nIteration 1. Residual norm: 15.0321.\r\nIteration 2. Residual norm: 0.588264.\r\nIteration 3. Residual norm: 0.00488507.\r\nIteration 4. Residual norm: 1.39924e-06.\r\nIteration 5. Residual norm: 7.94916e-12.","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Note that we get the same convergence pattern as on the CPU.","category":"page"},{"location":"quickstart.html#How-to-solve-the-linear-system-with-BICGSTAB?","page":"Quick start","title":"How to solve the linear system with BICGSTAB?","text":"","category":"section"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"By default, the algorithm runs with a direct solver, which might be inefficient for large problems. We might want to use an iterative solver instead. ExaPF.jl allows to use a block-Jacobi preconditioner:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"julia> const LS = ExaPF.LinearSolvers\r\njulia> npartitions = 8\r\njulia> precond = LS.BlockJacobiPreconditioner(jac, npartitions, CUDADevice())","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"The iterative linear solver is instantiated with:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"julia> linear_solver = ExaPF.BICGSTAB(precond)\r\n","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"By default, the tolerance of BICGSTAB is set to 1e-8:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"julia> linear_solver.tol\r\n1e-8","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"We need to update accordingly the tolerance of the Newton-Raphson algorithm, as it could not be lower than the tolerance of the iterative solver.","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"julia> convergence = ExaPF.powerflow(polar_gpu, jx_gpu, physical_state_gpu,\r\n                                     linear_solver=linear_solver,\r\n                                     tol=1e-7,\r\n                                     verbose_level=1)\r\nIteration 0. Residual norm: 26.6667.\r\nIteration 1. Residual norm: 15.0321.\r\nIteration 2. Residual norm: 0.588264.\r\nIteration 3. Residual norm: 0.00488507.\r\nIteration 4. Residual norm: 1.39925e-06.\r\nIteration 5. Residual norm: 1.81445e-09.\r\n","category":"page"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"CurrentModule = ExaPF.PowerSystem","category":"page"},{"location":"lib/powersystem.html#PowerSystem","page":"PowerSystem","title":"PowerSystem","text":"","category":"section"},{"location":"lib/powersystem.html#Description","page":"PowerSystem","title":"Description","text":"","category":"section"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"AbstractPowerSystem\r\nPowerNetwork","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.AbstractPowerSystem","page":"PowerSystem","title":"ExaPF.PowerSystem.AbstractPowerSystem","text":"AbstractPowerSystem\n\nFirst layer of the package. Store the topology of a given transmission network, including:\n\nthe power injection at each bus\nthe admittance matrix\nthe default voltage at each bus\n\nData are imported either from a matpower file, or a PSSE file.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.PowerNetwork","page":"PowerSystem","title":"ExaPF.PowerSystem.PowerNetwork","text":"PowerNetwork <: AbstractPowerSystem\n\nThis structure contains constant parameters that define the topology and physics of the power network.\n\nThe object PowerNetwork uses its own contiguous indexing for the buses. The indexing is independent from those specified in the Matpower or the PSSE input file. However, a correspondence between the two indexing (Input indexing to PowerNetwork indexing) is stored inside the attribute bus_to_indexes.\n\nNote\n\nThe object PowerNetwork is created in the main memory. Use a AbstractFormulation object to move data to the target device.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#API-Reference","page":"PowerSystem","title":"API Reference","text":"","category":"section"},{"location":"lib/powersystem.html#Network-elements","page":"PowerSystem","title":"Network elements","text":"","category":"section"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"AbstractNetworkElement","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.AbstractNetworkElement","page":"PowerSystem","title":"ExaPF.PowerSystem.AbstractNetworkElement","text":"AbstractNetworkElement\n\nAbstraction for all physical elements being parts of a AbstractPowerSystem. Elements are divided in\n\ntransmission lines (Lines)\nbuses (Buses)\ngenerators (Generators)\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"List of elements:","category":"page"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"Buses\r\nLines\r\nGenerator","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.Buses","page":"PowerSystem","title":"ExaPF.PowerSystem.Buses","text":"Buses <: AbstractNetworkElement\n\nBuses of a transmission network.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.Lines","page":"PowerSystem","title":"ExaPF.PowerSystem.Lines","text":"Lines <: AbstractNetworkElement\n\nLines of a transmission network.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.Generator","page":"PowerSystem","title":"ExaPF.PowerSystem.Generator","text":"Generator <: AbstractElement\n\nGenerator in a transmission network\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#Network-attributes","page":"PowerSystem","title":"Network attributes","text":"","category":"section"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"AbstractNetworkAttribute","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.AbstractNetworkAttribute","page":"PowerSystem","title":"ExaPF.PowerSystem.AbstractNetworkAttribute","text":"AbstractNetworkAttribute\n\nAttribute of a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"Function for getting attributes from a network:","category":"page"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"get","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.get","page":"PowerSystem","title":"ExaPF.PowerSystem.get","text":"get(pf::AbstractPowerSystem, attr::AbstractNetworkAttribute)\n\nReturn value of attribute attr in the AbstractPowerSystem object pf.\n\nget(pf::AbstractPowerSystem, attr::AbstractIndexing)\n\nReturn indexing corresponding to a subset of the buses.\n\nExamples\n\nnpq = get(pf, NumberOfPQBuses())\nnpv = get(pf, NumberOfPVBuses())\nindex_pv = get(pf, PVIndexes()())\nindex_gen = get(pf, GeneratorIndexes()())\n\n\n\n\n\n\n","category":"function"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"List of attributes:","category":"page"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"NumberOfBuses\r\nNumberOfLines\r\nNumberOfGenerators\r\nNumberOfPVBuses\r\nNumberOfPQBuses\r\nNumberOfSlackBuses\r\nBaseMVA","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.NumberOfBuses","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfBuses","text":"NumberOfBuses <: AbstractNetworkAttribute\n\nNumber of buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.NumberOfLines","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfLines","text":"NumberOfLines <: AbstractNetworkAttribute\n\nNumber of lines in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.NumberOfGenerators","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfGenerators","text":"NumberOfGenerators <: AbstractNetworkAttribute\n\nNumber of generators in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.NumberOfPVBuses","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfPVBuses","text":"NumberOfPVBuses <: AbstractNetworkAttribute\n\nNumber of PV buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.NumberOfPQBuses","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfPQBuses","text":"NumberOfPQBuses <: AbstractNetworkAttribute\n\nNumber of PQ buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.NumberOfSlackBuses","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfSlackBuses","text":"NumberOfSlackBuses <: AbstractNetworkAttribute\n\nNumber of slack buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.BaseMVA","page":"PowerSystem","title":"ExaPF.PowerSystem.BaseMVA","text":"BaseMVA <: AbstractNetworkAttribute\n\nBase MVA of the network.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"Query the indexing of the different elements in a given network:","category":"page"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"PVIndexes\r\nPQIndexes\r\nSlackIndexes\r\nGeneratorIndexes\r\n","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.PVIndexes","page":"PowerSystem","title":"ExaPF.PowerSystem.PVIndexes","text":"PVIndexes <: AbstractIndexing\n\nIndexes of the PV buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.PQIndexes","page":"PowerSystem","title":"ExaPF.PowerSystem.PQIndexes","text":"PQIndexes <: AbstractIndexing\n\nIndexes of the PQ buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.SlackIndexes","page":"PowerSystem","title":"ExaPF.PowerSystem.SlackIndexes","text":"SlackIndexes <: AbstractIndexing\n\nIndexes of the slack buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.GeneratorIndexes","page":"PowerSystem","title":"ExaPF.PowerSystem.GeneratorIndexes","text":"GeneratorIndexes <: AbstractIndexing\n\nIndexes of the generators in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#Network-values","page":"PowerSystem","title":"Network values","text":"","category":"section"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"AbstractNetworkValues","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.AbstractNetworkValues","page":"PowerSystem","title":"ExaPF.PowerSystem.AbstractNetworkValues","text":"AbstractNetworkValues\n\nNumerical values attached to the different attributes of the network.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"List of values:","category":"page"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"VoltageMagnitude\r\nVoltageAngle\r\nActivePower\r\nReactivePower\r\n","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.VoltageMagnitude","page":"PowerSystem","title":"ExaPF.PowerSystem.VoltageMagnitude","text":"VoltageMagnitude <: AbstractNetworkValues\n\nMagnitude |v| of the voltage v = |v| exp(i θ).\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.VoltageAngle","page":"PowerSystem","title":"ExaPF.PowerSystem.VoltageAngle","text":"VoltageAngle <: AbstractNetworkValues\n\nAngle θ of the voltage v = |v| exp(i θ).\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.ActivePower","page":"PowerSystem","title":"ExaPF.PowerSystem.ActivePower","text":"ActivePower <: AbstractNetworkValues\n\nActive power P of the complex power S = P + iQ.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.ReactivePower","page":"PowerSystem","title":"ExaPF.PowerSystem.ReactivePower","text":"ReactivePower <: AbstractNetworkValues\n\nReactive power Q of the complex power S = P + iQ.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"Function to get the range of a given value:","category":"page"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"bounds","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.bounds","page":"PowerSystem","title":"ExaPF.PowerSystem.bounds","text":"bounds(pf::AbstractPowerSystem, attr::AbstractNetworkAttribute, val::AbstractNetworkValues)\n\nReturn lower and upper bounds corresponding to the admissible values of the AbstractNetworkAttribute attr.\n\nExamples\n\np_min, p_max = bounds(pf, Generator(), ActivePower())\nv_min, v_max = bounds(pf, Buses(), VoltageMagnitude())\n\n\n\n\n\n\n","category":"function"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"CurrentModule = ExaPF\r\nDocTestSetup = quote\r\n    using ExaPF\r\n    const AD = ExaPF.AD\r\nend\r\nDocTestFilters = [r\"ExaPF\"]","category":"page"},{"location":"man/autodiff.html#AutoDiff","page":"AutoDiff","title":"AutoDiff","text":"","category":"section"},{"location":"man/autodiff.html#Overview","page":"AutoDiff","title":"Overview","text":"","category":"section"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"Given a set of equations F(x) = 0, the Newton-Raphson algorithm for solving nonlinear equations (see below) requires the Jacobian J = jacobian(x) of F. At each iteration a new step dx is computed by solving a linear system. In our case J is sparse and indefinite.","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"    go = true\r\n    while(go)\r\n        dx .= jacobian(x)\\f(x)\r\n        x  .= x .- dx\r\n        go = norm(f(x)) < tol ? true : false\r\n    end","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"There are two modes of differentiation called forward/tangent or reverse/adjoint. The latter is known in machine learning as backpropagation. The forward mode generates Jacobian-vector product code tgt(x,d) = J(x) * d, while the adjoint mode generates code for the transposed Jacobian-vector product adj(x,y) = (J(x)'*y). We recommend the book Evaluating derivatives: principles and techniques of algorithmic differentiation by Griewank and Walther[1] for a more in-depth introduction to automatic differentiation. The computational complexity of both models favors the adjoint mode if the number of outputs of F is much smaller than the number of inputs size(x) >> size(F), like for example the loss functions in machine learning. However, in our case F is a multivariate vector function from mathbbR^n to mathbbR^n, where n is the number of buses.","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"(Image: Jacobian coloring \\label{fig:coloring})","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"To avoid a complexity of mathcalO(n) cdot cost(F) by letting the tangent mode run over all Cartesian basis vectors of mathbbR^n, we apply the technique of Jacobian coloring to compress the sparse Jacobian J. Running the tangent mode, it allows to compute columns of the Jacobian concurrently, by combining independent columns in one Jacobian-vector evaluation (see \\autoref{fig:coloring}). For sparsity detection we rely on the greedy algorithm implemented by SparseDiffTools.jl.","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"Given the sparsity pattern, the forward model is applied through the package ForwardDiff.jl. Given the number of Jacobian colors c we can build our dual type t1s with c directions:","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"t1s{N} = ForwardDiff.Dual{Nothing,Float64, N} where N}","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"Note that a second-order type t2s can be created naturally by applying the same logic to t1s:","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"t2s{M,N} =  ForwardDiff.Dual{Nothing,t1s{N}, M} where M, N}","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"Finally, this dual type can be ported to both vector types Vector and CuVector:","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"VT = Vector{Float64}\r\nVT = Vector{t1s{N}}}\r\nVT = CuVector{t1s{N}}}","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"Setting VT to either of the three types allows us to instantiate code that has been written using the broadcast operator .","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"x .= a .* b","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"or accessed in kernels written for KernelAbstractions.jl like for example the power flow equations (here in polar form):","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"@kernel function residual_kernel!(F, v_m, v_a,\r\n                                  ybus_re_nzval, ybus_re_colptr, ybus_re_rowval,\r\n                                  ybus_im_nzval, ybus_im_colptr, ybus_im_rowval,\r\n                                  pinj, qinj, pv, pq, nbus)\r\n\r\n    npv = size(pv, 1)\r\n    npq = size(pq, 1)\r\n\r\n    i = @index(Global, Linear)\r\n    # REAL PV: 1:npv\r\n    # REAL PQ: (npv+1:npv+npq)\r\n    # IMAG PQ: (npv+npq+1:npv+2npq)\r\n    fr = (i <= npv) ? pv[i] : pq[i - npv]\r\n    F[i] -= pinj[fr]\r\n    if i > npv\r\n        F[i + npq] -= qinj[fr]\r\n    end\r\n    @inbounds for c in ybus_re_colptr[fr]:ybus_re_colptr[fr+1]-1\r\n        to = ybus_re_rowval[c]\r\n        aij = v_a[fr] - v_a[to]\r\n        coef_cos = v_m[fr]*v_m[to]*ybus_re_nzval[c]\r\n        coef_sin = v_m[fr]*v_m[to]*ybus_im_nzval[c]\r\n        cos_val = cos(aij)\r\n        sin_val = sin(aij)\r\n        F[i] += coef_cos * cos_val + coef_sin * sin_val\r\n        if i > npv\r\n            F[npq + i] += coef_cos * sin_val - coef_sin * cos_val\r\n        end\r\n    end\r\nend","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"These two abstractions are a powerful tool that allow us to implement the forward mode in vectorized form where the number of directions or tangent components of a tangent variable are the number of Jacobian colors. We illustrate this in \\autoref{fig:simd} with a point-wise vector product x .* y","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"(Image: SIMD AD for point-wise vector product \\label{fig:simd})","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"This natural way of computing the compressed Jacobian yields a very high performing code that is portable to any vector architecture, given that a similar package like CUDA.jl exists. We note that similar packages for the Intel Compute Engine and AMD ROCm are in development called oneAPI.jl and AMDGPU.jl, respectively. We expect our package to be portable to AMD and Intel GPUs in the future.","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"[1]: Griewank, Andreas, and Andrea Walther. Evaluating derivatives: principles and techniques of algorithmic differentiation. Society for Industrial and Applied Mathematics, 2008.","category":"page"},{"location":"index.html#ExaPF","page":"Home","title":"ExaPF","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"ExaPF.jl is a package to solve powerflow problem on exascale architecture. ExaPF.jl aims to implement a reduced method for solving the optimal power flow problem (OPF) fully on GPUs. Reduced methods enforce the constraints, represented here by the power flow's (PF) system of nonlinear equations, separately at each iteration of the optimization in the reduced space. This paper describes the API of ExaPF.jl for solving the power flow's nonlinear equations (NLE) entirely on the GPU. This includes the computation of the derivatives using automatic differentiation, an iterative linear solver with a preconditioner, and a Newton-Raphson implementation. All of these steps allow us to run the main computational loop entirely on the GPU with no transfer from host to device.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This implementation will serve as the basis for the future optimal power flow (OPF) implementation as a nonlinear programming problem (NLP) in the reduced space.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"To make our implementation portable to CPU and GPU architectures we leverage two abstractions: arrays and kernels. Both of these abstractions are supported through the packages CUDA.jl and KernelAbstractions.jl Please take a look at the autodiff and linear solver implementations to get a design overview of ExaPF.jl targeted for GPUs.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The user API is separated into three layers:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"First layer: Physical layer, specify the power network topology in powersystem\nSecond layer: Interface between power network and NLE or NLP in formulations\nThird layer: Evaluators for non-linear problems","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The third layer is for users working in optimization whereas the first layer is for electrical engineers. They meet in the second layer.","category":"page"},{"location":"index.html#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"index.html#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\r\n    \"quickstart.md\",\r\n    \"man/autodiff.md\",\r\n    \"man/linearsolver.md\",\r\n    \"man/powersystem.md\",\r\n    \"man/formulations.md\",\r\n    \"man/evaluators.md\",\r\n]\r\nDepth = 1","category":"page"},{"location":"index.html#Library","page":"Home","title":"Library","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\r\n    \"lib/autodiff.md\",\r\n    \"lib/linearsolver.md\",\r\n    \"lib/powersystem.md\",\r\n    \"lib/formulations.md\",\r\n    \"lib/evaluators.md\",\r\n]\r\nDepth = 1","category":"page"},{"location":"index.html#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This research was supported by the Exascale Computing Project (17-SC-20-SC), a joint project of the U.S. Department of Energy’s Office of Science and National Nuclear Security Administration, responsible for delivering a capable exascale ecosystem, including software, applications, and hardware technology, to support the nation’s exascale computing imperative.","category":"page"},{"location":"lib/evaluators.html","page":"Evaluators","title":"Evaluators","text":"CurrentModule = ExaPF","category":"page"},{"location":"lib/evaluators.html#Evaluators","page":"Evaluators","title":"Evaluators","text":"","category":"section"},{"location":"lib/evaluators.html#Description","page":"Evaluators","title":"Description","text":"","category":"section"},{"location":"lib/evaluators.html","page":"Evaluators","title":"Evaluators","text":"AbstractNLPEvaluator","category":"page"},{"location":"lib/evaluators.html#ExaPF.AbstractNLPEvaluator","page":"Evaluators","title":"ExaPF.AbstractNLPEvaluator","text":"AbstractNLPEvaluator\n\nAbstractNLPEvaluator implements the bridge between the problem formulation (see AbstractFormulation) and the optimization solver. Once the problem formulation bridged, the evaluator allows to evaluate in a straightfoward fashion the objective and the different constraints, but also the corresponding gradient and Jacobian objects.\n\n\n\n\n\n","category":"type"},{"location":"lib/evaluators.html","page":"Evaluators","title":"Evaluators","text":"When working in the reduced space, we could use the corresponding ReducedSpaceEvaluator:","category":"page"},{"location":"lib/evaluators.html","page":"Evaluators","title":"Evaluators","text":"ReducedSpaceEvaluator","category":"page"},{"location":"lib/evaluators.html#ExaPF.ReducedSpaceEvaluator","page":"Evaluators","title":"ExaPF.ReducedSpaceEvaluator","text":"ReducedSpaceEvaluator{T} <: AbstractNLPEvaluator\n\nEvaluator working in the reduced space corresponding to the control variable u. Once a new point u is passed to the evaluator, the user needs to call the method update! to find the corresponding state x(u) satisfying the equilibrium equation g(x(u), u) = 0.\n\nTaking as input a given AbstractFormulation, the reduced evaluator builds the bounds corresponding to the control u and the state x, and initiate an AutoDiffFactory tailored to the problem. The reduced evaluator could be instantiated on the main memory, or on a specific device (currently, only CUDA is supported).\n\n\n\n\n\n","category":"type"},{"location":"lib/evaluators.html","page":"Evaluators","title":"Evaluators","text":"The bridge to MathOptInterface is encoded by the MOIEvaluator structure:","category":"page"},{"location":"lib/evaluators.html","page":"Evaluators","title":"Evaluators","text":"MOIEvaluator","category":"page"},{"location":"lib/evaluators.html#ExaPF.MOIEvaluator","page":"Evaluators","title":"ExaPF.MOIEvaluator","text":"MOIEvaluator <: MOI.AbstractNLPEvaluator\n\nBridge from a ExaPF.AbstractNLPEvaluator to a MOI.AbstractNLPEvaluator.\n\nAttributes\n\nnlp::AbstractNLPEvaluator: the underlying ExaPF problem.\nhash_x::UInt: hash of the last evaluated variable x\nhas_hess::Bool (default: false): if true, pass a Hessian structure to MOI.\n\n\n\n\n\n","category":"type"},{"location":"lib/evaluators.html#API-Reference","page":"Evaluators","title":"API Reference","text":"","category":"section"},{"location":"lib/evaluators.html#Attributes","page":"Evaluators","title":"Attributes","text":"","category":"section"},{"location":"lib/evaluators.html","page":"Evaluators","title":"Evaluators","text":"Variables\r\nConstraints\r\nn_variables\r\nn_constraints\r\n","category":"page"},{"location":"lib/evaluators.html#ExaPF.Variables","page":"Evaluators","title":"ExaPF.Variables","text":"Variables <: AbstractNLPAttribute end\n\nAttribute corresponding to the optimization variables attached to a given AbstractNLPEvaluator.\n\n\n\n\n\n","category":"type"},{"location":"lib/evaluators.html#ExaPF.Constraints","page":"Evaluators","title":"ExaPF.Constraints","text":"Constraints <: AbstractNLPAttribute end\n\nAttribute corresponding to the constraints  attached to a given AbstractNLPEvaluator.\n\n\n\n\n\n","category":"type"},{"location":"lib/evaluators.html#ExaPF.n_variables","page":"Evaluators","title":"ExaPF.n_variables","text":"n_variables(nlp::AbstractNLPEvaluator)\n\nGet the number of variables in the problem.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#ExaPF.n_constraints","page":"Evaluators","title":"ExaPF.n_constraints","text":"n_constraints(nlp::AbstractNLPEvaluator)\n\nGet the number of constraints in the problem.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#Callbacks","page":"Evaluators","title":"Callbacks","text":"","category":"section"},{"location":"lib/evaluators.html","page":"Evaluators","title":"Evaluators","text":"objective\r\ngradient!\r\nconstraint!\r\njacobian_structure!\r\njacobian!\r\njtprod!\r\nhessian!\r\n","category":"page"},{"location":"lib/evaluators.html#ExaPF.objective","page":"Evaluators","title":"ExaPF.objective","text":"objective(nlp::AbstractNLPEvaluator, u)::Float64\n\nEvaluate the objective at point u.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#ExaPF.gradient!","page":"Evaluators","title":"ExaPF.gradient!","text":"gradient!(nlp::AbstractNLPEvaluator, g, u)\n\nEvaluate the gradient of the objective at point u. Store the result inplace in the vector g, which should have the same dimension as u.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#ExaPF.constraint!","page":"Evaluators","title":"ExaPF.constraint!","text":"constraint!(nlp::AbstractNLPEvaluator, cons, u)\n\nEvaluate the constraints of the problem at point u. Store the result inplace, in the vector cons.\n\nNote\n\nThe vector cons should have the same dimension as the result returned by n_constraints(nlp).\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#ExaPF.jacobian_structure!","page":"Evaluators","title":"ExaPF.jacobian_structure!","text":"jacobian_structure!(nlp::AbstractNLPEvaluator, rows, cols)\n\nReturn the sparsity pattern of the Jacobian matrix.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#ExaPF.jacobian!","page":"Evaluators","title":"ExaPF.jacobian!","text":"jacobian!(nlp::ReducedSpaceEvaluator, jac, u)\n\nEvaluate the Jacobian of the constraints at position u. Store the result inplace, in the array jac.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#ExaPF.jtprod!","page":"Evaluators","title":"ExaPF.jtprod!","text":"jtprod!(nlp::ReducedSpaceEvaluator, jv, u, v)\n\nEvaluate the transpose Jacobian-vector product J^T v. The vector jv is modified inplace.\n\nLet (n, m) = n_variables(nlp), n_constraints(nlp).\n\nu is a vector with dimension n\nv is a vector with dimension m\njv is a vector with dimension n\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#ExaPF.hessian!","page":"Evaluators","title":"ExaPF.hessian!","text":"hessian!(nlp::AbstractNLPEvaluator, hess, u)\n\nEvaluate the Hessian of the problem at point u. Store the result inplace, in the vector hess.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#Utilities","page":"Evaluators","title":"Utilities","text":"","category":"section"},{"location":"lib/evaluators.html","page":"Evaluators","title":"Evaluators","text":"reset!\r\nprimal_infeasibility\r\nprimal_infeasibility!","category":"page"},{"location":"lib/evaluators.html#ExaPF.reset!","page":"Evaluators","title":"ExaPF.reset!","text":"reset!(nlp::AbstractNLPEvaluator)\n\nReset evaluator nlp to default configuration.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#ExaPF.primal_infeasibility","page":"Evaluators","title":"ExaPF.primal_infeasibility","text":"primal_infeasibility(nlp::AbstractNLPEvaluator, u)\n\nReturn primal infeasibility associated to current model nlp evaluated at control u.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators.html#ExaPF.primal_infeasibility!","page":"Evaluators","title":"ExaPF.primal_infeasibility!","text":"primal_infeasibility!(nlp::AbstractNLPEvaluator, cons, u)\n\nReturn primal infeasibility associated to current model nlp evaluated at control u. Modify vector cons inplace.\n\n\n\n\n\n","category":"function"}]
}
